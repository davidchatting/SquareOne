/*--------------------------------------------------------------------------------------*//*											*//*		Joerg Anders, TU Chemnitz, Fakultaet fuer Informatik, GERMANY		*//*		ja@informatik.tu-chemnitz.de						*//*											*//*											*//*--------------------------------------------------------------------------------------*//*											*//* This program is free software; you can redistribute it and/or modify it under the	*//* terms of the GNU General Public License as published by the Free Software		*//* Foundation; either version 2 of the License, or (at your option) any later version.	*//*											*//* This program is distributed in the hope that it will be useful, but WITHOUT ANY	*//* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	*//* PARTICULAR PURPOSE. See the GNU General Public License for more details.		*//*											*//* You should have received a copy of the GNU General Public License along with this	*//* program; (See "LICENSE.GPL"). If not, write to the Free Software Foundation, Inc.,	*//* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.				*//*											*//*--------------------------------------------------------------------------------------*//*											*//* If the program runs as Java applet it isn't "interactive" in the sense of the GNU 	*//* General Public License. So paragraph 2c doesn't apply.				*//*											*//****************************************************************************************/ package de.tuchemnitz.informatik.MPEG_Play; import java.awt.*;				// Image, Frame, BorderLayoutimport java.io.*;				// DataInputStream, IOExceptionimport java.net.*;				// URL, MalformedURLExceptionimport java.applet.Applet;import java.awt.image.*;			// ColorModell, DirectColorModel, MemoryImageSource/**	The class "Element" can store the information of a single frame. * 	Exactly "MAXELEMENT" objects of this class exist in an array "EL_ARR[]" which is used in wrap around manner. * 	The pixels are given as YUV values and they are then translated into the Java-AWT RGB model.<p> * 	 * 	Made this class public and put in its own .java file, <a href="mailto:djc@cs.bham.ac.uk">David Chatting</a> 13th December 1999.<p> * 	 * 	<a href="http://rnvs.informatik.tu-chemnitz.de/~ja/MPEG/HTML/mpeg_tech.html">Technical discussion on this class</a><p> * 	 * 	<a href="http://rnvs.informatik.tu-chemnitz.de/~ja/MPEG/MPEG_Play.html">MPEG Play homepage</a> * 	@author Joerg Anders (ja@informatik.tu-chemnitz.de) *	@version MPEG JAVA v3.4 */public class Element {     	/**	The Image */	public Image Picture;		/**	notice the frame number (display order) */	public int Frame_idx;		/**	I, B or P */	public int Frame_type;			/**	The pixels in Java RGB model */	public int Pix_Map[];			/**	1.402*2^16 */	private final int CR_FAC = 0x166EA;		/**	1.772*2^16 */	private final int CB_FAC = 0x1C5A2; 		/**	0.71414 * 2^16 */	private final int CR_DIFF_FAC = 0xB6D2;		/**	0.34414 * 2^16 */	private final int  CB_DIFF_FAC = 0x581A;		/**	The dimensions of the frame */	private int w, h, o_w, o_h;				/**	The constructor notices the frame sizes and produces an image and an array	 * 	to store the RGB pixel values .  The Applet (app) object is necessary to call	 * 	the "createImage" routine.	 * 		 * 	Made public DJC 13th December 1999	 */	public Element (Applet app, ColorModel cm, int w, int h, int o_w, int o_h) {		Pix_Map = new int[w * h]; // memory for the translated RGB values		Picture = app.createImage(new MemoryImageSource(o_w, o_h, cm, Pix_Map, 0, w));		this.o_w = o_w; this.o_h = o_h; this.w = w; this.h = h;	}      	/**	The method "Make_Picture" is called every time the scanner has decoded a frame.	 * 	It expects the frame information as YUV values and translates them into the	 * 	Java RGB color system.	 */	public void Make_Picture(int Pixels[][], int f_idx, int f_type) {		int red, green, blue, luminance, cr, cb, cr_g, cb_g, i, j;		Frame_idx = f_idx; Frame_type = f_type; // notice		/*  because one crominance information is applied to 4 luminace values		 *  2 "pointers" are established, which point to the 2 lines containing		 *  the appropriate luminace values:		 */		int lum_idx1 = 0, lum_idx2 = w;		int size = w * h;				/*		 *  expand the list		 */		size >>>= 2;		 // the size of the crominance values				for (i = 0; i < size; i++) { // for all crominance values ...			cb = Pixels[2][i] - 128; // extract the			cr = Pixels[1][i] - 128; // chrominace information			cr_g = cr * CR_DIFF_FAC;			cb_g = cb * CB_DIFF_FAC;					cb *= CB_FAC;			cr *= CR_FAC;			for (j = 0; j < 2; j++) { // apply to 2 neighbouring points				 luminance = Pixels[0][lum_idx1] << 16; // extract lum.				 red = (luminance + cr);				 blue = (luminance + cb) >> 16;				 green = (luminance - cr_g - cb_g) >> 8;				 red = (red > 0xff0000) ? 0xff0000 : (red < 0) ? 0 : red & 0xff0000; 	// CLAMP				 green = (green > 0xff00)  ? 0xff00 : (green < 0) ? 0 : green & 0xff00;//CLAMP				 blue = (blue > 255)  ? 255 : (blue < 0) ? 0 : blue;	//CLAMP				 Pix_Map[lum_idx1] =  ( red | green  | blue);					 lum_idx1++; // next point in first line					 luminance = Pixels[0][lum_idx2] << 16; // extract lum.				 red = (luminance + cr);				 blue = (luminance + cb) >> 16;				 green = (luminance - cr_g - cb_g) >> 8;				 red = (red > 0xff0000) ? 0xff0000 : (red < 0) ? 0 : red & 0xff0000; 	// CLAMP				 green = (green > 0xff00)  ? 0xff00 : (green < 0) ? 0 : green & 0xff00;//CLAMP				 blue = (blue > 255)  ? 255 : (blue < 0) ? 0 : blue;	//CLAMP				 Pix_Map[lum_idx2] =  ( red  | green  | blue);				 lum_idx2++; // next point in second line				 if (lum_idx2 % w == 0) { // end of line ?					lum_idx2 += w;					lum_idx1 += w;				 }			}		}		Picture.flush(); // Make sure that the new pixel values are taken	}}