/****************************************************************************************//*											*//*				"MPEG_Play.java.jit"					*//*											*//* This is the main class file for the JIT version of the Java MPEG inline player. In	*//* contrast to the original version the decoded pictures are not saved for a later 	*//* play step. Instead the pictures are shown already during decoding step and it is	*//* assumed that the JIT (Java just-in-time compiler) is fast enought to produce about	*//* 5 to 7 frames per second.								*//*											*//* The class "Element" can hold one picture. An array "EL_ARR[]" holds "MAXELEMENT"	*//* of these "Element"s. It is used in wrap around manner. To store some pictures is	*//* necessary because in MPEG file the coding order is not the display order. (See also:	*//*											*//*	http://rnvs.informatik.tu-chemnitz.de/~ja/MPEG/HTML/mpeg_tech.html	)	*//*											*//* The class "MPEG_Play" is the main Applet. It reads the input MPEG stream and starts	*//* 2 threads:										*//*			- ScanThread : Scanning of the MPEG Stream			*//*			- AnimatorThread: which shows the already scanned frames	*//*											*//* These 2 threads are controlled by an object of the class "Dispatcher". The "Dis-	*//* patcher suspends the "AnimatorThread" until a new picture arrives from "ScanThread".	*//* If a picture arrives the "AnimatorThread" wakes up and shows the new picture.	*//*											*//* In case of an application a method "main()" is implemented.				*//*--------------------------------------------------------------------------------------*//*											*//*		Joerg Anders, TU Chemnitz, Fakultaet fuer Informatik, GERMANY		*//*		ja@informatik.tu-chemnitz.de						*//*											*//*											*//*--------------------------------------------------------------------------------------*//*											*//* This program is free software; you can redistribute it and/or modify it under the	*//* terms of the GNU General Public License as published by the Free Software		*//* Foundation; either version 2 of the License, or (at your option) any later version.	*//*											*//* This program is distributed in the hope that it will be useful, but WITHOUT ANY	*//* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	*//* PARTICULAR PURPOSE. See the GNU General Public License for more details.		*//*											*//* You should have received a copy of the GNU General Public License along with this	*//* program; (See "LICENSE.GPL"). If not, write to the Free Software Foundation, Inc.,	*//* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.				*//*											*//*--------------------------------------------------------------------------------------*//*											*//* If the program runs as Java applet it isn't "interactive" in the sense of the GNU 	*//* General Public License. So paragraph 2c doesn't apply.				*//*											*//****************************************************************************************/ package de.tuchemnitz.informatik.MPEG_Play; import java.awt.*;				// Image, Frame, BorderLayoutimport java.io.*;				// DataInputStream, IOExceptionimport java.net.*;				// URL, MalformedURLExceptionimport java.applet.Applet;import java.awt.image.*;			// ColorModell, DirectColorModel, MemoryImageSource/**	An object of class "dispatch" is used to control the "ScanThread" and the "AnimatorThread". * 	The "AnimatorThread" displays the frames and some other information. * 	It waites as long as no new frame is available. The "ScanThread" informs the "AnimatorThread" of the arrival of the new frame * 	and waits until the "AnimatorThread" has taken the new frame.<p> * 	 * 	<a href="http://rnvs.informatik.tu-chemnitz.de/~ja/MPEG/MPEG_Play.html">MPEG Play homepage</a> * 	@author Joerg Anders (ja@informatik.tu-chemnitz.de) *	@version MPEG JAVA v3.4 */class dispatch {	protected int newframe = 0;	protected boolean available = false;	public synchronized int get() {		available = false;		notifyAll();		while (!available) {			try {				wait();			} catch (InterruptedException e) {				System.out.println("Exception : " + e.toString());			}		}		return newframe;	}	public synchronized void put(int akEle) {		newframe = akEle;		available = true;		notifyAll();		while (available)  {			try {				wait();			} catch (InterruptedException e) {				System.out.println("Exception : " + e.toString());			}		}	}}/**	The class "MPEG_Play" is the main applet. * 	It starts the "ScanThread" and the "AnimatorThread" which work concurrently. The "ScanThread" informs the * 	"AnimatorThread" of the arrival of a new frame. The "AnimatorThread" takes * 	this frame and shows it an the Applet surface.<p> * 	 * 	<a href="http://rnvs.informatik.tu-chemnitz.de/~ja/MPEG/MPEG_Play.html">MPEG Play homepage</a> * 	@author Joerg Anders (ja@informatik.tu-chemnitz.de) *	@version MPEG JAVA v3.4 */public class MPEG_Play extends Applet implements Runnable {    	/**	width and height	*/	protected int h, w;				/**	width and height of the original pictures */	protected int o_h, o_w;					/**	Is it an applet or an application ? */	public boolean inApplet = true;		/**	The scanner object */	protected MPEG_scan M_Scan;				/**	Name of input file */	protected static String filename;		/**	THE frame (in application) */	protected Frame the_frame;		/**	THE MPEG resource */	protected InputStream in_stream = null;		/**	THE dispatcher */	protected dispatch Dispatcher = new dispatch();			/**	a border */	protected final int R = 55;				/**	the animation runs as thread */   	protected Thread AnimatorThread = null;		/**	the scanner runs as thread */   	protected Thread ScanThread = null;				/**	last P or I frame */	protected int last_P_or_I = 0;		protected DirectColorModel cm = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);		/**	to build the URL to MPEG resource */	protected URL source_url = null;		/**	The last frame in "EL_ARR[]" */	protected int Frame_nr = 0;				/**	Next frame in display order */	protected int ak_nr;					/**	Number of "Element"s in "EL_ARR[]" */	protected final int MAXELEMENT = 10;	protected Element EL_ARR[] = new Element[MAXELEMENT];	/** This constructor is only called in application	 */	MPEG_Play(InputStream s, myFrame f, boolean ud) {		in_stream = s;		// notice		the_frame = f;		// notice		inApplet = false;	// notice	}	/**	This constructor is only called in applet	 */	public MPEG_Play() {}	protected boolean open_url() {		boolean io = true;	// everything OK ????		String f_name = null;	// to read the filename parameter		if (inApplet) {// otherwise the file is already opened			try {			// obtain parameters				f_name = getParameter("FILENAME");				source_url = new URL(getCodeBase(), f_name);				in_stream = source_url.openStream();			}			catch (NullPointerException e) {				Err.Msg = "no parameter \"FILENAME\"";				io = false;	                }			catch (MalformedURLException e) {				Err.Msg = "MalformedURLException";				io = false;			}			catch (IOException e) {				Err.Msg = "Cannot open: " + getCodeBase() + "/" + f_name;				io = false;			}			if (f_name == null) {				Err.Msg = "no parameter \"FILENAME\"";				io = false;			}		}		return io;	}	/**	The method "init()" opens up the MPEG resource and produces and starts the "ScanThread"	 */	public void start () {		boolean io = true;	// everything OK ????		if (io = open_url()) { // create the scanner object and start the scanner thread:			M_Scan = new MPEG_scan(this, in_stream);			ScanThread = new Thread(M_Scan);			ScanThread.start();		}		if (io && AnimatorThread == null) {	           	AnimatorThread = new Thread(this); // create the "AnimatorThread"	           	AnimatorThread.start();      	   // pass the thread to the scheduler;							   // The "AnimatorThread" works							   // concurrently with the		}					   // "ScanThread"	}	public void stop() {		AnimatorThread = null; // stop animation loop		if (ScanThread != null) ScanThread.stop();     // stop scanning		try {			if (in_stream != null) in_stream.close(); // the stream must be opened again		}		catch (IOException e) {}	}	/**	The method "close_chain()" is called after the scanner is ready.	 *	In JIT version it simply stops the "AnimatorThread" because there is no display step.	 */	public void close_chain() {		try {			in_stream.close();		}		catch (IOException e) {			Err.Msg = "error: close";		}		if (inApplet) {			if (!open_url()) {				Err.Msg = "error in open_url()";			}		}		else {			try {				in_stream = new DataInputStream(new FileInputStream(filename));			}			catch (IOException e) {				Err.Msg = "error: open"; System.out.flush();			}		}		last_P_or_I  = Frame_nr = 0;		M_Scan.reset(in_stream);		ScanThread = new Thread(M_Scan);		ScanThread.start();		Dispatcher.get(); // block Animator Thread	        //AnimatorThread = new Thread(this); // create the "AnimatorThread"	        //AnimatorThread.start();      	   // pass the thread to the scheduler;		System.gc();	}	/**	The method "run()" implements the "AnimatorThread".	 * 	It waits in "Dispatcher.get()". Then it calls "repaint()" to activate "update()".	 *	"update()" displays a the new image.	 */	public void run() { 		while (AnimatorThread != null) { // not dead; in scan phase			ak_nr = Dispatcher.get();  // wait till a new frame arrives			repaint();		       // activate (probably) "update"			try {				Thread.yield();	       // give "ScanThread" a chance 			}			catch (Exception e) { // don't know what to do in applet				System.out.println("Exception: " + e.toString());			}		}	}	/**	This method is necessary because the scanner must have the possibility to resize the applet	 * 	and (possibly) the frame once he has recognized the dimensions of the MPEG frames.	 *	This method is called by the "ScanThread".	*/	public void set_dim (int width, int height, int o_width, int o_height) {		w = width; h = height; // The width in MPEG stream		o_w = o_width; o_h = o_height; // The original width		resize(width < 250 ? 250 : o_width, o_height + R);		if (!inApplet) {			 the_frame.resize(width < 250 ? 250 : o_width, o_height + R);			 the_frame.setLayout( new BorderLayout());			 the_frame.add("Center", this);			 the_frame.setTitle("JAVA-MPEG-Player");			 the_frame.show();		}		// produce the "MAXELEMENT" "Elements":		for (int i = 0; i < MAXELEMENT; i++) {			EL_ARR[i] = new Element(this, cm, w, h, o_w, o_h);		}	}	/**	The method "set_Pixels" expects the pixel data,	 * 	the type and number of the next frame in display order to change the pixel values of the next image.	 * 	It determins the number of the next frame in display	 * 	order (which differes from coding order) and passes it to the "AnimatorThread" by means of the "Dispatcher".	 */	public void set_Pixels(int Pixels[][], int f_idx, int f_type) {		EL_ARR[Frame_nr].Make_Picture(Pixels, f_idx, f_type);		/* put the frame into the list in display order: */		if (f_type == MPEG_video.B_TYPE) { // B - Frames are already in display order			Dispatcher.put(Frame_nr); // inform the dispatcher of the arrival of a new frame		}		else { // a P or I frame; they are not necessary in display order			Dispatcher.put(last_P_or_I); // inform the dispatcher of the arrival of a new frame			last_P_or_I = Frame_nr;	     // notice for later insertion;		}		try {				// give the "AnimatorThread"			Thread.sleep(50);	// 50 msec to show the frame.		}		catch (Exception e) {	// don't know what to do in applet			System.out.println("Exception : " + e.toString());		}		Frame_nr = (Frame_nr + 1) % MAXELEMENT; // wrap around!	}	/**	The method "update" displays the actual frame on the surface of the Applet.	 * 	If an error occured it calls "paint()" to show the error message.	 */   	public void update(Graphics g) {  // overwrites the "update()" - method of Applet		if (Err.Msg != null) { // error ?			paint(g);			return;		}		String Type_s = null;		switch(EL_ARR[ak_nr].Frame_type) {			case MPEG_video.I_TYPE: Type_s = " (I_FRAME) decoded"; break;			case MPEG_video.B_TYPE: Type_s = " (B_FRAME) decoded"; break;			case MPEG_video.P_TYPE: Type_s = " (P_FRAME) decoded"; break;			default: Type_s = " (unknown (" + EL_ARR[ak_nr].Frame_type + ")"; break;		}		g.setColor(getBackground()); // clear background		g.fillRect(0, o_h, 250, R + 15);		g.setColor(Color.black);		g.drawString("Frame Nr. " + EL_ARR[Frame_nr].Frame_idx + Type_s, 10, o_h + 15);		g.drawImage(EL_ARR[ak_nr].Picture, 0, 0, this);	}	/**	The method "paint()" is only called in error case.	 * 	It displays the	error message.	 */	public void paint(Graphics g) {		if (Err.Msg != null) {			if (!inApplet) {				the_frame.resize(200, 60);			}			resize(200, 60);			g.setColor(getBackground());			g.fillRect(0, 0, o_w, o_h);			g.setColor(Color.black);			g.drawString(Err.Msg, 1, 15);			if (!inApplet) {				System.out.println(Err.Msg);				System.exit(10);			}		}	}	/**	If the program runs as application the method "main()" is called at first.	 *	It creates a frame to get a display surface.	 */	public static void main( String args[] ) {		InputStream fis = null;		boolean userdelay = false;		if (args.length < 1) {			System.err.println("wrong argument count");			System.exit(10);		}		try {			filename = args[0];			fis = new DataInputStream(new FileInputStream(args[0]));		}		catch (IOException e) {			System.out.println("can't open " + args[0]);			System.exit(10);		}		new myFrame(fis, userdelay);	}}