/****************************************************************************************//*											*//*				"MPEG_Play.java"					*//*											*//* This file contains the main applet class and the class "Element" which stores	*//* pixel information of a single frame. Furthermore a class "dispatch" is implmeneted   *//* The object of this class controls the to threads:					*//*			- ScanThread : Scanning of the MPEG Stream			*//*			- AnimatorThread: which shows in scan phase how many		*//*					  frames are already scanned.			*//*											*//* In case of an application a method "main()" is implemented.				*//*--------------------------------------------------------------------------------------*//*											*//*		Joerg Anders, TU Chemnitz, Fakultaet fuer Informatik, GERMANY		*//*		ja@informatik.tu-chemnitz.de						*//*											*//*											*//*--------------------------------------------------------------------------------------*//*											*//* This program is free software; you can redistribute it and/or modify it under the	*//* terms of the GNU General Public License as published by the Free Software		*//* Foundation; either version 2 of the License, or (at your option) any later version.	*//*											*//* This program is distributed in the hope that it will be useful, but WITHOUT ANY	*//* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A	*//* PARTICULAR PURPOSE. See the GNU General Public License for more details.		*//*											*//* You should have received a copy of the GNU General Public License along with this	*//* program; (See "LICENSE.GPL"). If not, write to the Free Software Foundation, Inc.,	*//* 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.				*//*											*//*--------------------------------------------------------------------------------------*//*											*//* If the program runs as Java applet it isn't "interactive" in the sense of the GNU 	*//* General Public License. So paragraph 2c doesn't apply.				*//*											*//****************************************************************************************/package de.tuchemnitz.informatik.MPEG_Play;import java.awt.*;				// Image, Frame, BorderLayoutimport java.io.*;				// DataInputStream, IOExceptionimport java.net.*;				// URL, MalformedURLExceptionimport java.applet.Applet;import java.awt.image.*;			// ColorModel, DirectColorModel, MemoryImageSource/* The class "Element" can store the information of a single frame. By means of the	*//* property "next" it can build a list whose anchor is "Frame_List" in class 		*//* "MPEG_Play".										*//* The pixels are given as YUV values and they are then translated into the Java-AWT	*//* RGB model.										*/class Element { 	public Element next = null, before = null;	// To make the list	private boolean b_type_seen = false;		// Was there already a B-Frame ???	public Image Picture;				// The Image	public int Frame_idx;				// notice the frame number (display order)	public int Frame_type;				// I, B or P	public int Pix_Map[];				// The pixels in Java RGB model	private final int CR_FAC = 0x166EA; /* 1.402*2^16 */	private final int CB_FAC = 0x1C5A2; /* 1.772*2^16 */	private final int CR_DIFF_FAC = 0xB6D2; /* 0.71414 * 2^16 */	private final int  CB_DIFF_FAC = 0x581A; /* 0.34414 * 2^16 */	/* The constructor is called every time the scanner has decoded a frame. It 	   */	/* expects the frame information as YUV values and translates them into the Java   */	/* RGB color system. The Applet (app) object is necessary to call the 		   */	/* "createImage" routine. The dispatcher "s" is informed of the existance of a	   */	/*  new frame. 						   			   */	Element (Applet app, int Pixels[][], ColorModel cm, int f_idx, int f_type, int w, int h, int o_w, int o_h) {		int red, green, blue, luminance, cr, cb, cr_g, cb_g, i, j;		Frame_idx = f_idx; Frame_type = f_type; // notice		Element ptr;		/*  because one crominance information is applied to 4 luminace values		 *  2 "pointers" are established, which point to the 2 lines containing		 *  the appropriate luminace values:		 */		int lum_idx1 = 0, lum_idx2 = w;		int size = w * h;		Pix_Map = new int[size]; // memory for the translated RGB values				/*		 *  expand the list		 */		size >>>= 2;		 // the size of the crominance values				for (i = 0; i < size; i++) { // for all crominance values ...			cb = Pixels[2][i] - 128; // extract the			cr = Pixels[1][i] - 128;// chrominace information			cr_g = cr * CR_DIFF_FAC;			cb_g = cb * CB_DIFF_FAC;					cb *= CB_FAC;			cr *= CR_FAC;			for (j = 0; j < 2; j++) { // apply to 2 neighbouring points				 luminance = Pixels[0][lum_idx1] << 16; // extract lum.				 red = (luminance + cr);				 blue = (luminance + cb) >> 16;				 green = (luminance - cr_g - cb_g) >> 8;				 red = (red > 0xff0000) ? 0xff0000 : (red < 0) ? 0 : red & 0xff0000; 	// CLAMP				 green = (green > 0xff00)  ? 0xff00 : (green < 0) ? 0 : green & 0xff00;//CLAMP				 blue = (blue > 255)  ? 255 : (blue < 0) ? 0 : blue;	//CLAMP				 Pix_Map[lum_idx1] =  ( red | green  | blue);					 lum_idx1++; // next point in first line					 luminance = Pixels[0][lum_idx2] << 16; // extract lum.				 red = (luminance + cr);				 blue = (luminance + cb) >> 16;				 green = (luminance - cr_g - cb_g) >> 8;				 red = (red > 0xff0000) ? 0xff0000 : (red < 0) ? 0 : red & 0xff0000; 	// CLAMP				 green = (green > 0xff00)  ? 0xff00 : (green < 0) ? 0 : green & 0xff00;//CLAMP				 blue = (blue > 255)  ? 255 : (blue < 0) ? 0 : blue;	//CLAMP				 Pix_Map[lum_idx2] =  ( red  | green  | blue);				 lum_idx2++; // next point in second line				 if (lum_idx2 % w == 0) { // end of line ?					lum_idx2 += w;					lum_idx1 += w;				 }			}		}/*+++ JAVA offers 2 possibilities to create an image:				+++*//*+++										+++*//*+++			1. createImage(int width, int height);			+++*//*+++			2. createImage(ImageProducer producer);			+++*/		/*+++										+++*//*+++ The first method isn't suitable here because it requires to draw the	+++*//*+++ pixel values by means of a sequence of "draw...()" methods into the image.+++*//*+++ Since all the pixel values and the color model are known the images 	+++*//*+++ are produced according to the second method by means of objects of the	+++*//*+++ class "MemoryImageSource" which implements the interface "ImageProducer".	+++*//*+++ An image producer is an object which supplies the pixel values on demand  +++*//*+++ of an image consumer. The pixel values are delivered in recpect of a 	+++*//*+++ certain color model. The "MemoryImageSource" objects uses a Direct Color  +++*//*+++ model.									+++*/		Picture = app.createImage(new MemoryImageSource(o_w, o_h, cm, Pix_Map, 0, w));	}}/* An object of class "dispatch" is used to control the "ScanThread" and the	*//* "AnimatorThread" during scan phase. The "AnimatorThread" displays information*//* of the state of the scanning process. It waites as long as no new frame	*//* is available. The "ScanThread" does never wait. The (pardonable) effect is:	*//* The user isn't necessarily informed of all scanned frames.			*/class dispatch {	private Element newframe = null;	private boolean available = false;	public synchronized Element get() {		if (available == false) {			try {				wait();			} catch (InterruptedException e) {				Err.Msg = "Exception : " + e.toString();			}		}		available = false;		notifyAll();		return newframe;	}	public synchronized void put(Element akEle) {		newframe = akEle;		available = true;		notifyAll();	}}/* The class "MPEG_Play" is the main applet. Its work is divides into 2 phases:	*//*	- scanning: A "ScanThread" and an "AnimatorThread" work concurrently	*//*		    The "ScanThread" produces a list of frames (images) and	*//*		    informes the "AnimatorThread" if a frame is decoded.	*//*	- display:  By means of the method "Element.close_chain()"  the list	*//*		    of frames is closed to a ring of frames. After that		*//*		    the frames are displayed. The "ScanThread" dies and the 	*//*		    "AnimatorThread" begins to display the frames.		*/public class MPEG_Play extends Applet implements Runnable {	private int h, w;				// width and height	private int o_h, o_w;				// width and height of the original pictures	private Element ak_pic = null;			// No. of the actual frame	public boolean inApplet = true;			// Is it an applet or an application ?	private Frame the_frame;			// THE frame (in application)	private InputStream in_stream = null;		// THE MPEG resource	private dispatch Dispatcher = new dispatch();	// THE dispatcher	private Element akElement = null;		// the actual element	private final int R = 55;			// a border   	private Thread AnimatorThread = null;  // the animation runs as thread   	private Thread ScanThread = null;      // the scanner runs as thread	private boolean Scanning = true;       // in scan phase ???	private boolean first = true;	       // for the first time in display phase ?		boolean painted = false;		// "true", if the frame "ak_pic_nr" is painted	private static int delay = 50;		// default delay between 2 frames (in ms)	private boolean userdelay = false;	private Element Frame_List = null;	// The anchor	private Element last_Element = null;	// last element in list	private Element last_P_or_I = null;	// last P or I frame;	private boolean b_type_seen = false;	private DirectColorModel cm = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);	private final int MINDELAY = 50, MAXDELAY = 400, DELTA = 20;	private final int LEFT = 1, RIGHT = 2;	private final int BU_W = 40, BU_H = 20, SPA = 5, BU_SPACE = 5;	private int playdir;			// direction of animation	private Button stop = new Button("stop");	private Button leftleft = new Button("<<");	private Button left = new Button("<-");	private Button right= new Button("->");	private Button rightright= new Button(">>");	private Button qb   = new Button("Quit");	private URL old_url = null;	// to what URL belongs the decoded list	private URL source_url = null;	// to build the URL to MPEG resource	/* This constructor is only called in application */	MPEG_Play(InputStream s, myFrame f, boolean ud) {		in_stream = s;		// notice		the_frame = f;		// notice		inApplet = false;	// notice		userdelay = ud;		// notice	}	public MPEG_Play() {} 	// This constructor is only called in applet	/* The method "init()" opens up the MPEG resource and produces and */	/* starts the "ScanThread"					   */	public void start () {		MPEG_scan M_Scan;	// The scanner object		String s_delay;		// to read the delay parameter		boolean io = true;	// everything OK ????		String f_name = null;	// to read the filename parameter		if (inApplet) {// otherwise the file is already opened			try {			// obtain parameters				f_name = getParameter("FILENAME");				s_delay = getParameter("DELAY");				if (s_delay != null) {					if (s_delay.compareTo("user") == 0) {						userdelay = true;					}					else {		            			try {		                			delay = Integer.parseInt(s_delay);		            			} catch (NumberFormatException e) { 							io = false;							Err.Msg = s_delay + " is not a number";						}					}				}				source_url = new URL(getCodeBase(), f_name);				in_stream = source_url.openStream();			}			catch (NullPointerException e) {				Err.Msg = "no parameter \"FILENAME\"";				io = false;	                }			catch (MalformedURLException e) {				Err.Msg = "MalformedURLException";				io = false;			}			catch (IOException e) {				Err.Msg = "Cannot open: " + getCodeBase() + "/" + f_name;				io = false;			}			if (f_name == null) {				Err.Msg = "no parameter \"FILENAME\"";				io = false;			}			if (Frame_List != null && inApplet) {				if (!source_url.sameFile(old_url)) { // already scanned ?					Frame_List = last_Element = last_P_or_I = null; // clear up for scanning process					Scanning = true;				}			}		}		if (io && Frame_List == null) { // create the scanner object and start the scanner thread:			M_Scan = new MPEG_scan(this, in_stream);			ScanThread = new Thread(M_Scan);			ScanThread.start();		}		playdir = RIGHT;		if (AnimatorThread == null) {	           	AnimatorThread = new Thread(this); // create the "AnimatorThread"	           	AnimatorThread.start();      	   // pass the thread to the scheduler;							   // At first the "AnimatorThread" works							   // concurrently with the		}					   // "ScanThread"	}	public void stop() {		AnimatorThread = null; // stop animation loop		if (ScanThread != null) ScanThread.stop();     // stop Scanning		if (Scanning) {        // reset all in scanning process			Frame_List = last_Element = last_P_or_I = null; // clear up for scanning process			try {				if (in_stream != null) in_stream.close(); // the stream must be opened again			}			catch (IOException e) {}		}	}	/* The method "close_chain()" is called after the scanner is ready.	*/	/* It closed the list of Elements and establishes a ring of Images      */	/* this way.								*/	public void close_chain() {		last_Element.next = last_P_or_I; 		last_P_or_I.before = last_Element;		last_Element = last_P_or_I;		last_Element.next = Frame_List;		Frame_List.before = last_Element;		ak_pic = Frame_List;		Scanning = false;		// inform the "AnimatorThread"		Dispatcher.put(Frame_List);	// unlock the "AnimatorThread"		try {			in_stream.close();		}		catch (Exception e) {};		if (inApplet) {			try {				old_url = new URL(source_url.toString()); // notice;			}			catch (Exception e) {				Err.Msg = e.toString();			}		}	}	/* The method "run()" implements the "AnimatorThread". During scan phase */	/* is waits in "Dispatcher.get()". Then it calls "repaint()" to activate */	/* "update()". In scan phase "update()" only prints a decoder status	 */	/* information to the user.						 */	/* After scan phase the frames are displayed.				 */	public void run() { 		while (AnimatorThread != null && Scanning) { // not dead; in scan phase			akElement = Dispatcher.get();  // wait till a new frame arrives			repaint();		       // activate (probably) "update"			try {				Thread.yield();	       // give "ScanThread" a chance 			}			catch (Exception e) { // don't know what to do in applet				Err.Msg = "Exception: " + e.toString();			}		}		if (userdelay && AnimatorThread != null) { // avoid the buttons in case							   // of stopping the scanner			removeAll(); // make sure the buttons are not existent			try {				Thread.yield();	       // give the browser a chance to			}			       // remove the buttons			catch (Exception e) { // don't know what to do in applet				Err.Msg = "Exception: " + e.toString();			}			leftleft.reshape(0, o_h + BU_SPACE, BU_W, BU_H);			add(leftleft);			left.reshape(BU_W + SPA, o_h + BU_SPACE, BU_W, BU_H);			add(left);			stop.reshape(2 * (BU_W + SPA), o_h + BU_SPACE, BU_W, BU_H);			add(stop);			right.reshape(3 * (BU_W + SPA), o_h + BU_SPACE, BU_W, BU_H);			add(right);			rightright.reshape(4 * (BU_W + SPA), o_h + BU_SPACE, BU_W, BU_H);			add(rightright);			if (!inApplet) {				qb.reshape(4 * (BU_W + SPA) / 2, o_h + BU_SPACE + BU_H, BU_W, BU_H);				add(qb);			}		}   		long starttime = System.currentTimeMillis();  // notice the start time   		while (AnimatorThread != null) { // Is it me ?        		repaint(); // sets the flag for "update()" --> "paint()"			painted = false;        		try {  // "sleep()" throws the "InterruptedException"           			starttime += delay; // compute the destination time           			// if destination time isn't reached --> sleep           			Thread.sleep(Math.max(0,starttime - System.currentTimeMillis()));        		}        		catch (InterruptedException e) { // must be; otherwise it leads to an error           			break;   // because "sleep()" throws the "InterruptedException"			}			/* "ak_pic" is only incremented if the Web browser  */			/* had the opportunity to paint the current image.     */			/* ("repaint()" sets only a flag: "Please repaint      */			/* occasionally!")				       */			if (painted) {				if (playdir == RIGHT) {					ak_pic = ak_pic.next;				}				else {					ak_pic = ak_pic.before;				}			}		}	}	/* This method is necessary because the scanner must have the possibility */	/* to resize the applet and (possibly) the frame once he has recognized	  */	/* the dimensions of the MPEG frames.					  */	/* This method is called by the "ScanThread".				  */	public void set_dim (int width, int height, int o_width, int o_height) {		w = width; h = height; // The width in MPEG stream		o_w = o_width; o_h = o_height; // The original width		resize(width < 250 ? 250 : o_width, o_height + R);		if (!inApplet) {			 the_frame.resize(width < 250 ? 250 : o_width, o_height + R + 20);			 the_frame.setLayout( new BorderLayout());			 the_frame.add("Center", this);			 the_frame.setTitle("JAVA-MPEG-Player");			 the_frame.show();		}	}	/* The method "set_Pixels" expects the pixel data, the type and number	*/	/* of the next frame in display order to produce an new frame-"Element".*/	/* Then it places the new Element at the appropriate position in List.	*/	/* It is called in "ScanThread".					*/	public void set_Pixels(int Pixels[][], int f_idx, int f_type) {		Element newElement = new Element(this, Pixels, cm, f_idx, f_type, w, h, o_w, o_h);		/* put the frame into the list in display order: */		if (Frame_List == null) { // first Element			b_type_seen = false;			Frame_List = last_Element = newElement;			Dispatcher.put(newElement); // inform the dispatcher of the arrival of a new frame		}		else if (f_type == MPEG_video.B_TYPE) { // B - Frames are already in display order			b_type_seen = true;			last_Element.next = newElement;			newElement.before = last_Element;			last_Element = newElement;			Dispatcher.put(newElement); // inform the dispatcher of the arrival of a new frame		}		else { // a P or I frame; they are not necessary in display order			if (last_P_or_I != null) { // last I or P frame				last_Element.next = last_P_or_I; // place behind B-Frames				last_P_or_I.before = last_Element;				last_Element = last_P_or_I;				Dispatcher.put(last_P_or_I); // inform the dispatcher of the arrival of a new frame			}			last_P_or_I = newElement;	     // notice for later insertion;		}		try {				// give the "AnimatorThread"			Thread.sleep(50);	// 50 msec to inform the user		}				// of the arrival of the new frame		catch (Exception e) {	// don't know what to do in applet			Err.Msg = "Exception : " + e.toString();		}	}	/* The method "action" is the event handler and is called whenever the	*/	/* user pushed a button. It determins the button and changes the 	*/	/* behaviour of the animation.						*/	public boolean action(Event  evt, Object  what) {		if (evt.target == leftleft) {			moreleft();			return super.action(evt, what);		}		else if(evt.target == left) {			stopanim();			ak_pic = ak_pic.before;			repaint();			return super.action(evt, what);		}		else if (evt.target == stop) {			stopanim();			return super.action(evt, what);		}		else if(evt.target == right) {			stopanim();			ak_pic = ak_pic.next;			repaint();			return super.action(evt, what);		}		else if (evt.target == rightright) {			moreright();			return super.action(evt, what);		}		else if (evt.target == qb) {			System.exit(10);		}		return super.action(evt, what);	}	/* The method "moreleft()" increases the speed of backward	*/	/* palying or decreases the speed of forward playing		*/	private void moreleft() {		if (AnimatorThread == null) {			delay = 50;			playdir = LEFT;			AnimatorThread = new Thread(this);			AnimatorThread.start();			return;		}		if (playdir == LEFT) {			if ((delay -= DELTA) < MINDELAY) delay = MINDELAY;			return;		}		if ((delay += DELTA) > MAXDELAY) stopanim();	}			/* The method "moreleft()" increases the speed of forward	*/	/* palying or decreases the speed of backward playing		*/	private void moreright() {		if (AnimatorThread == null) {			delay = 50;			playdir = RIGHT;			AnimatorThread = new Thread(this);			AnimatorThread.start();				return;		}		if (playdir == RIGHT) {			if ((delay -= DELTA) < MINDELAY) delay = MINDELAY;			return;		}		if ((delay += DELTA) > MAXDELAY) stopanim();	}	private void stopanim() {		AnimatorThread = null;	}	/* The method "update" must decide whether the program is in	*/	/* scan phase or not. If so, it displays the actual scan state	*/	/* to the user. Otherwise it displays the next frame.		*/	/* If an error occured it calls "paint()" to show the error 	*/	/* message.							*/   	public void update(Graphics g) {  // overwrites the "update()" - method of Applet		if (Err.Msg != null) { // error ?			paint(g);			return;		}		if (Scanning) {			if (akElement != null) {				String Type_s = null;				switch(akElement.Frame_type) {					case MPEG_video.I_TYPE: Type_s = " (I_FRAME) decoded"; break;					case MPEG_video.B_TYPE: Type_s = " (B_FRAME) decoded"; break;					case MPEG_video.P_TYPE: Type_s = " (P_FRAME) decoded"; break;					default: Type_s = "unknown"; break;				}				g.setColor(getBackground()); // clear background				g.fillRect(0, o_h, 250, R + 20);				g.setColor(Color.red);				g.drawString("Decoding WAIT!!!" , 10, o_h + 15);				g.setColor(Color.black);				g.drawString("Frame Nr. " + akElement.Frame_idx + Type_s, 10, o_h + 30);				g.drawImage(akElement.Picture, 0, 0, this);				return;			}		}		if (ak_pic == null) return;		g.drawImage(ak_pic.Picture, 0, 0, this);		painted = true; // "is painted" --> see "run()"		if (first) { // change the status string to "Playing"			first = false;			g.setColor(getBackground());	                g.fillRect(0, o_h, 250, R + 20);	                g.setColor(Color.black);			if (!userdelay) {	                	g.drawString("Playing", 10, o_h + 15);			}		}	}	/* The method "paint()" is only called in error case. It displays the	*/	/* error message.							*/	public void paint(Graphics g) {		if (Err.Msg != null) {			if (!inApplet) {				the_frame.resize(200, 60);			}			resize(200, 60);			g.setColor(getBackground());			g.fillRect(0, 0, o_w, o_h);			g.setColor(Color.black);			g.drawString(Err.Msg, 1, 15);			if (!inApplet) {				System.out.println(Err.Msg);				System.exit(10);			}		}	}	/* If the program runs as application the method "main()" is called at first.	*/	/* It creates a frame to get a display surface.					*/	public static void main( String args[] ) {		InputStream fis = null;		boolean userdelay = false;		if (args.length < 1) {			System.err.println("wrong argument count");			System.exit(10);		}		try {			fis = new DataInputStream(new FileInputStream(args[0]));		}		catch (IOException e) {			System.out.println("can't open " + args[0]);			System.exit(10);		}		if (args.length == 2) {			if (args[1].compareTo("user") == 0) {				userdelay = true;			}			else {				try {					delay = Integer.parseInt(args[1]);				}				catch (Exception e) {					System.out.println(args[1] + " is not a number");					System.out.println("Usage: Mpeg_Play <file>.mpg [<delay> | user]");					System.exit(10);				}			}		}		new myFrame(fis, userdelay);	}}