//5th March 2000package uk.ac.bham.cs.djc.time;import java.io.Serializable;import java.io.IOException;import uk.ac.bham.cs.djc.mediaDescriptors.TemporalMediaBlock;import uk.ac.bham.cs.djc.*;/**	Associates a score with a specified feature and a period of temporal media<p> * 	 * 	<a href="Feature.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 5th March 2000 */public class Feature extends TemporalMediaBlock implements Serializable{    /**	Unique name for this feature */        protected String featureName;        /**	Scores associated with this feature */    protected float scores[];        /**	Create a new Feature     *	@param	newFeatureName the name of the new feature    *	@param	temporalMediaBlock the TemporalMediaBlock which describes this period    *	@param	time the time at which to set the interest (milliseconds)    *	@param	interest the interest to set    *	@exception	Exception if this feature does not describe the specified time    */    public Feature(String newFeatureName,TemporalMediaBlock temporalMediaBlock,int time,float interest) throws Exception{	this(newFeatureName,temporalMediaBlock);		setScore(time,interest);    }        /**	Create a new Feature     *	@param	newFeatureName the name of the new feature    *	@param	temporalMediaBlock the TemporalMediaBlock which describes this period    *	@param	time the time at which to set the interest (milliseconds)    *	@param	interestGaussian the gaussian distribution of scores to set    *	@exception	Exception if this feature does not describe the specified time    */    public Feature(String newFeatureName,TemporalMediaBlock temporalMediaBlock,int time,Gaussian interestGaussian) throws Exception{	this(newFeatureName,temporalMediaBlock);		setScore(time,interestGaussian);    }        /**	Create a new Feature      *	@param	newFeatureName the name of the new feature     *	@param	temporalMediaBlock the TemporalMediaBlock which describes this period     */    public Feature(String newFeatureName,TemporalMediaBlock temporalMediaBlock) {	super(temporalMediaBlock);		//Set the feature's name:	featureName=new String(newFeatureName);		//Make an array of the correct length for the interest scores:	int duration_S=periodOfMedia.getDuration()/1000;	int arrayLength=(int)(duration_S*getSampleRate());	scores=new float[arrayLength];    }        /**	Get the name of this feature     *	Name should be unique - this is not ensured    *	@return	the name of this feature    */    public String getFeatureName() {	return(featureName);    }        /**	Get the number of scores associated with this period of temporal media     * 	@return	the number of scores associated with this period of temporal media     */    public int getNumberOfElements() {	return(scores.length);    }        /**	Set the period which this feature refers to     *	This is the only safe way to change the period,     *	so that the scores array is changed to reflect this     *	@param	newStart the new start time (milliseconds)     *	@param	newFinish the new finish time (milliseconds)     *	CURRENTLY PERIOD MUST BE SUBSET OF ORIGINAL     */    public void setPeriod(int newStart,int newFinish) throws Exception {	//Copy subset of array:	System.arraycopy(scores,getIndexOfTime(newStart),scores,0,getIndexOfTime(newFinish)-getIndexOfTime(newStart));		//Set new period:	periodOfMedia.setPeriod(newStart,newFinish);    }        /**	Set this interest value at this time     *	@param	time the time in milliseconds at which to set this interest     *	@param	interest the interest to set at this time     *	@exception	Exception if this feature does not describe the specified time     */    public void setScore(int time,float interest) throws Exception{	//if(This instance of the Feature class does not describe the specified time):	if(time<periodOfMedia.getStart() || time>periodOfMedia.getFinish()) {	    throw new Exception("This instance of the Feature class does not describe time: " + time);	}	//if(This instance of the Feature class does describe the specified time):	else {	    //Calculate index to set:	    int relativeTime=time-periodOfMedia.getStart();	    float timePerElement=getTimePerElement();	    int indexToSet=(int)(((float)relativeTime)/timePerElement);	    	    try {		//Try to set the interest at this index:	    	//setScoreAtIndex(indexToSet,interest);	      	setConfidence(interest,indexToSet);	    }	    catch(ArrayIndexOutOfBoundsException aoube) {		throw new Exception("This instance of the Feature class does not describe time: " + time);	    }	}    }        /**	Set the interest defined by this gaussian at this time      *	@param	time the time in milliseconds at which to set this interest     *	@param	interestGaussian the gaussian distribution describing interest     *	@exception	Exception if this Feature does not describe time specified     */    public void setScore(int time,Gaussian interestGaussian) throws Exception{	//if(This instance of the Feature class does not describe the specified time):	if(time<periodOfMedia.getStart() || time>periodOfMedia.getFinish()) {	    throw new Exception("This instance of the Feature class does not describe time: " + time);	}	//if(This instance of the Feature class does describe the specified time):	else {	    //Calculate index to set:	    int relativeTime=time-periodOfMedia.getStart();	    float timePerElement=getTimePerElement();	    int indexToSet=(int)(((float)relativeTime)/timePerElement);	    	    //If this is out of bounds exception will be passed up from this method	    try {		//Set centre value of gaussian:	    	//setScoreAtIndex(indexToSet,(float)interestGaussian.valueAt(0));	      	setConfidence((float)interestGaussian.valueAt(0),indexToSet);	    	int n=1;				//while(the next points on the distribution make a difference):	    	while(interestGaussian.valueAt(n)>interestGaussian.getOffset()) {			//Set the scores symetrically:		    	try {			    	//Try to set the interest at this index:				//setScoreAtIndex(indexToSet+n,(float)interestGaussian.valueAt(+(n*Math.round(timePerElement))));				setConfidence((float)interestGaussian.valueAt(+(n*Math.round(timePerElement))),indexToSet+n);			}			catch(ArrayIndexOutOfBoundsException ofbe1) {			}			try {			    	//Try to set the interest at this index:		    		//setScoreAtIndex(indexToSet-n,(float)interestGaussian.valueAt(-(n*Math.round(timePerElement))));				setConfidence((float)interestGaussian.valueAt(-(n*Math.round(timePerElement))),indexToSet-n);			}			catch(ArrayIndexOutOfBoundsException ofbe2) {			}			n++;	    	}	    }	    catch(IndexOutOfBoundsException ioobe) {		//Gaussian value is zero at given index	    }	}    }        /**	Add this confidence at this element of the scores array     *	The confidence can be a max of 1, once this is exceeded the value is clipped to 1     * 	@param	index the index of the scores array at which to set the score     * 	@param	confidence the confidence to set at this index     * 	@exception	Exception if the confidence is not between 0 and 1     */    public void setConfidence(float confidence,int index) throws Exception{	if(confidence<0f || confidence>1f) throw new Exception("confidence (" + confidence +") is not between 0 and 1");		scores[index]+=confidence;	//If over 100% sure that this feature exists - clip to 100%	if(scores[index]>1f) scores[index]=1;    }        /**	Get the confidence at this element of the scores array     * 	@param	index the index of the scores array at which to set the score     * 	@return	the confidence to set at this index     * 	@exception	ArrayIndexOutOfBoundsException if the index specifed does not refer to a confidence     */    public float getConfidence(int index) throws ArrayIndexOutOfBoundsException{	float result=scores[index];		return(result);    }        /**	Get the amount of time (mS) assigned to each element of scores array     * 	@return	the amount of time (mS) assigned to each element of scores array     */    public float getTimePerElement() {	float timePerElement=((float)periodOfMedia.getDuration())/((float)scores.length);		return(timePerElement);    }        /**	For a given index of the scores array return the associated time     *	@param	index the index of the scores array to get the time of    *	@return	the time in milliseconds associated with this index    */    public int getTimeOfIndex(int index) {	int startTime=periodOfMedia.getStart();	float timePerElement=getTimePerElement();		//Calculate time:	int timeOfIndex=startTime+(int)(((float)index)*timePerElement);		return(timeOfIndex);    }        /**	Return the associated index in the scores array for the given time     * 	@param	time the time (in milliseconds) for which the associated index in the scores array is required     * 	@return	the associated index in the scores array for the given time     * 	@exception	Exception if this instance of the Feature class does not describe the specified time     */    public int getIndexOfTime(int time) throws Exception{	int relativeTime=time-periodOfMedia.getStart();		//if(This instance of the Feature class does not describe the specified time):	if(relativeTime<0 || time>periodOfMedia.getFinish()) {	    throw new Exception("Time, " + time + ", is not recorded by this feature");	}		//Calculate the index:	int index=(int)(((float)relativeTime)/getTimePerElement());		return(index);    }        /**	Return the score at the specified time     * 	@param	time the time (in milliseconds) at which the score is required     * 	@return	the score at the specified time     * 	@exception Exception if this instance of the Feature class does not describe the specified time     */    public float getScoreAtTime(int time) throws Exception{	return(getScoreAtIndex(getIndexOfTime(time)));    }        /**	Return the score at the specified index     *	@param	index the index of the scores array at which to get the score     *	@return	the score at the specified index     *	@exception ArrayIndexOutOfBoundsException if specified index is out of bounds     */    public float getScoreAtIndex(int index) throws ArrayIndexOutOfBoundsException {	return(getConfidence(index));    }        /**	Return true/false at the specified index     * 	If the confidence>0.5 true, false otherwise     *	@param	index the index of the scores array at which to get the score     *	@return	true/false     *	@exception ArrayIndexOutOfBoundsException if specified index is out of bounds     */    public boolean getBoolAtIndex(int index) throws ArrayIndexOutOfBoundsException {	boolean result=false;		if(getConfidence(index)>0.5f) result=true;		return(result);    }        /**	Add rhsFeature to this feature      *	@param	rhsFeature the right handside feature of this operation (infix notation),      *	where ths left handside feature is this     *	@return	the addition of this feature and rhsFeature     *	@exception Exception if features are of different sample rates     */    public Feature add(Feature rhsFeature) throws Exception{	Feature result=operate(rhsFeature,'+');		return(result);    }        /**	Subtract rhsFeature from this feature     *	@param	rhsFeature the right handside feature of this operation (infix notation),      *	where ths left handside feature is this     *	@return	the subtraction of rhsFeature from this feature      *	@exception Exception if features are of different sample rates     */    public Feature subtract(Feature rhsFeature) throws Exception{	Feature result=operate(rhsFeature,'-');		return(result);    }        /**	Divide this feature by rhsFeature      * 	This is a protected version of divide allowing closure     * 	If divisor is zero, result is one     * 	@param	rhsFeature the right handside feature of this operation (infix notation),      *	where ths left handside feature is this     *	@return	this feature divided by rhsFeature      *	@exception Exception if features are of different sample rates     */    public Feature divide(Feature rhsFeature) throws Exception{	Feature result=operate(rhsFeature,'/');		return(result);    }        /**	Multiply this feature by rhsFeature     * 	@param	rhsFeature the right handside feature of this operation (infix notation),      *	where ths left handside feature is this     *	@return	this feature multiplied by rhsFeature      *	@exception Exception if features are of different sample rates     */    public Feature multiply(Feature rhsFeature) throws Exception{	Feature result=operate(rhsFeature,'*');		return(result);    }        /**	Perform logical AND with this feature and rhsFeature     * 	@param	rhsFeature the right handside feature of this operation (infix notation),     *	where ths left handside feature is this     * 	@param	result preinstantiated Feature in which the result will be placed if not null     *	@return	this feature ANDed with rhsFeature      *	@exception Exception if features are of different sample rates     */    public Feature and(Feature rhsFeature,Feature result) throws Exception{	//if(features are of different sample rates):	if(getSampleRate()!=rhsFeature.getSampleRate()) {	    throw new Exception("Can't AND with Features of different sample rates");	}		//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String(getFeatureName() + " AND " + rhsFeature.getFeatureName());	if(result==null) result=new Feature(resultDescriptor,this);	else result.setDescription(resultDescriptor);		//for(each score in the rhsFeature's scores):	for(int index=0;index<rhsFeature.scores.length;index++) {	    if(getBoolAtIndex(index) && rhsFeature.getBoolAtIndex(index)) {		result.setConfidence(1f,index);	    }	}		return(result);    }        /**	Perform logical OR with this feature and rhsFeature     * 	@param	rhsFeature the right handside feature of this operation (infix notation),     *	where ths left handside feature is this     * 	@param	result preinstantiated Feature in which the result will be placed if not null     *	@return	this feature ORed with rhsFeature      *	@exception	Exception if features are of different sample rates     */    public Feature or(Feature rhsFeature,Feature result) throws Exception{	//if(features are of different sample rates):	if(getSampleRate()!=rhsFeature.getSampleRate()) {	    throw new Exception("Can't OR with Features of different sample rates");	}		//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String(getFeatureName() + " OR " + rhsFeature.getFeatureName());	if(result==null) result=new Feature(resultDescriptor,this);	else result.setDescription(resultDescriptor);		//for(each score in the rhsFeature's scores):	for(int index=0;index<rhsFeature.scores.length;index++) {	    if(getBoolAtIndex(index) || rhsFeature.getBoolAtIndex(index)) {		result.setConfidence(1f,index);	    }	}		return(result);    }        /**	Perform logical NAND with this feature and rhsFeature     * 	@param	rhsFeature the right handside feature of this operation (infix notation),     *	where ths left handside feature is this     *	@param	result preinstantiated Feature in which the result will be placed if not null     *	@return	this feature NANDed with rhsFeature      *	@exception	Exception if features are of different sample rates     */    public Feature nand(Feature rhsFeature,Feature result) throws Exception{	//if(features are of different sample rates):	if(getSampleRate()!=rhsFeature.getSampleRate()) {	    throw new Exception("Can't NAND with Features of different sample rates");	}		//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String(getFeatureName() + " NAND " + rhsFeature.getFeatureName());	if(result==null) result=new Feature(resultDescriptor,this);	else result.setDescription(resultDescriptor);		//for(each score in the rhsFeature's scores):	for(int index=0;index<rhsFeature.scores.length;index++) {	    if(getBoolAtIndex(index) && rhsFeature.getBoolAtIndex(index));	    else {		result.setConfidence(1f,index);	    }	}		return(result);    }        /**	Perform logical NOT on this feature     * 	@param	result preinstantiated Feature in which the result will be placed if not null     *	@return	this feature NOTed     */    public Feature not(Feature result) {	//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String("NOT " + getFeatureName());	if(result==null) result=new Feature(resultDescriptor,this);	else result.setDescription(resultDescriptor);		try {		result=nand(this,result);	}	catch(Exception e) {	    //This exception will never be thrown, as rhsFeature=this	}		return(result);    }        /**	Operate with this feature and rhsFeature using the operation specified by operatorChar     * 	@param	rhsFeature the right handside feature of this operation (infix notation),     *	where ths left handside feature is this     *	@param	operatorChar - specifies operation, can be: + - / (protected) *     *	Division is a protected version of divide allowing closure. If divisor is 0, result is 1.     *	@return	the resulting feature     *	@exception	Exception if features are of different sample rates      */    public Feature operate(Feature rhsFeature, char operatorChar) throws Exception{	//if(features are of different sample rates):	if(getSampleRate()!=rhsFeature.getSampleRate()) {	    throw new Exception("Can't " + operatorChar + " with Features of different sample rates");	}		//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String(getFeatureName() + operatorChar + rhsFeature.getFeatureName());	Feature result=new Feature(resultDescriptor,this);		//AND:	if(operatorChar=='&') {	    and(rhsFeature,result);	    return(result);	}		//OR:	if(operatorChar=='|') {	    or(rhsFeature,result);	    return(result);	}	//for(each score in the rhsFeature's scores):	for(int index=0;index<rhsFeature.scores.length;index++) {	    float interest=0f;	    	    //Do the appropiate operation:	    switch(operatorChar) {		case '+':interest=getScoreAtIndex(index)+rhsFeature.getScoreAtIndex(index);break;		case '-':interest=getScoreAtIndex(index)-rhsFeature.getScoreAtIndex(index);break;		case '/': {		    float rhsValue=rhsFeature.getScoreAtIndex(index);		    if(rhsValue==0f) interest=1f;		    else interest=getScoreAtIndex(index)/rhsValue;		    break;		}		case '*':interest=getScoreAtIndex(index)*rhsFeature.getScoreAtIndex(index);break;	    }	    	    //Set the result:	    //result.setScoreAtIndex(index,interest);	    result.setConfidence(interest,index);	}		return(result);    }        /**	Add offset to this feature     *	@param	offset the offset to add to this feature    *	@return	the resuting feature    *	@exception	Exception if features are of different sample rates     */    public Feature add(float offset) throws Exception{	Feature result=operate(offset,'+');		return(result);    }        /**	Subtract offset from this feature      *	@param	offset the offset to subtract from this feature     *	@return	the resuting feature     *	@exception	Exception if features are of different sample rates      */    public Feature subtract(float offset) throws Exception{	Feature result=operate(offset,'-');		return(result);    }        /**	Divide this feature by divisor     * 	This is a protected version of divide allowing closure     * 	If divisor is zero, result is one     * 	@param	divisor the divisor to divide the feature by     * 	@return	the resuting feature     * 	@exception	Exception if features are of different sample rates      */    public Feature divide(float divisor) throws Exception{	Feature result=operate(divisor,'/');		return(result);    }        /**	Multiply this feature by multiplier     *	@param	multiplier the multiplier by which this feature is multiplied    *	@return	the resuting feature    *	@exception	Exception if features are of different sample rates     */    public Feature multiply(float multiplier) throws Exception{	Feature result=operate(multiplier,'*');		return(result);    }    /**	Operate with this feature and rhsValue using the operation specified by operatorChar      *	@param	rhsValue The right handside value of this operation (infix notation),     *	where ths left handside feature is this     *	@param	operatorChar specifies operation, can be: + - /     *	Division is a protected version of divide allowing closure. If divisor is 0, result is 1.     *	@return	the resuting feature     *	@exception	Exception if features are of different sample rates      */    public Feature operate(float rhsValue, char operatorChar) throws Exception{	//Build a new descriptive name for the new resulting feature:	String resultDescriptor=new String(getFeatureName() + operatorChar + (new Float(rhsValue).toString()));	Feature result=new Feature(resultDescriptor,this);		//for(each score):	for(int index=0;index<scores.length;index++) {	    float interest=0f;	    	    //Do the appropiate operation:	    switch(operatorChar) {		case '+':interest=getScoreAtIndex(index)+rhsValue;break;		case '-':interest=getScoreAtIndex(index)-rhsValue;break;		case '/': {		    if(rhsValue==0f) interest=1f;		    else interest=getScoreAtIndex(index)/rhsValue;		    break;		}		case '*':interest=getScoreAtIndex(index)*rhsValue;break;	    }	    	    //Set the result:	    //result.setScoreAtIndex(index,interest);	    result.setConfidence(interest,index);	}		return(result);    }        /**	Operate on this feature using the operation specified by operationName      * 	@param	operationName specifies operation, can be: sum mean max min     * 	@return	the result of this operation     */    public float operate(String operationName) {	float result=0;		if(operationName.equals("sum")) result=sum();	else if(operationName.equals("mean")) result=mean();	else if(operationName.equals("max")) result=max();	else if(operationName.equals("min")) result=min();		return(result);    }        /**	Return the sum of all the scores in this feature     * 	@return	the sum of all the scores in this feature     */    public float sum() {	float result=0;		//for(each score)	for(int index=0;index<scores.length;index++) {	    //Add to result:	    result+=getScoreAtIndex(index);	}		return(result);    }        /**	Return the mean of all the scores in this feature     * 	@return	the mean of all the scores in this feature     */    public float mean() {	float result=0;		//Divide the sum by the number of scores:	result=sum()/scores.length;		return(result);    }        /**	Return the min score in this feature     * 	@return	the min score in this feature     */    public float min() {	float result=0;		//for(each score):	for(int index=0;index<scores.length;index++) {	    if(index==0) result=getScoreAtIndex(0);	    else {		if(getScoreAtIndex(index)<result) {		    //Set new min:		    result=getScoreAtIndex(index);		}	    }	}		return(result);    }        /**	Return the max score in this feature     * 	@return	the max score in this feature     */    public float max() {	float result=0;		//for(each score):	for(int index=0;index<scores.length;index++) {	    if(index==0) result=getScoreAtIndex(0);	    else {		if(getScoreAtIndex(index)>result) {		    //Set new max:		    result=getScoreAtIndex(index);		}	    }	}		return(result);    }        /**	Return a string respresentation of this object     * 	@return	the string respresentation of this object     */    public String toString() {	String stringToReturn=new String();		stringToReturn+="featureName:	" + featureName;	stringToReturn+=System.getProperty("line.separator");	stringToReturn+=super.toString();	stringToReturn+=System.getProperty("line.separator");	stringToReturn+="scores.length:	" + scores.length;	stringToReturn+=System.getProperty("line.separator");		//for(each score):	for(int index=0;index<scores.length;index++) {		stringToReturn+=(new Float(getScoreAtIndex(index))).toString();		stringToReturn+=System.getProperty("line.separator");	}	stringToReturn+=System.getProperty("line.separator");		return(stringToReturn);    }}