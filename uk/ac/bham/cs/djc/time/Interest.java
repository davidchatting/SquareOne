//20th Febraury 2000package uk.ac.bham.cs.djc.time;import java.util.Vector;import java.util.NoSuchElementException;import java.io.Serializable;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.FileOutputStream;import java.io.IOException;import uk.ac.bham.cs.djc.mediaDescriptors.TemporalMediaBlock;import uk.ac.bham.cs.djc.Equation;import uk.ac.bham.cs.djc.Gaussian;import uk.ac.bham.cs.djc.Properties;/**	Records a viewer's predicted interest for a period of media<p> * 	 * 	<a href="Interest.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 20th Febraury 2000 */public class Interest extends TemporalMediaBlock implements Serializable{    /**	Vector of features measured */    protected Vector features=new Vector();        /**	The period choosen as a summary */    protected Period summarisedPeriod=null;        /**	Create a new Interest object      *	@param	newPeriod the period over which the interest is predicted     *	@param	newSampleRate the sample rate of the media interest is measured for     */    public Interest(Period newPeriod, double newSampleRate) {	super(newPeriod,newSampleRate);    }        /**	Create a new Interest object      *	@param	temporalMediaBlock make an instance of Interest to describe this TemporalMediaBlock     */    public Interest(TemporalMediaBlock temporalMediaBlock) {	super(temporalMediaBlock);    }        /**	Set score of named feature, at given time      *	@param	featureName the name of the feature to set     *	@param	time the time in milliseconds at which to set this score     *	@param	interest the interest score to set     *	@exception	Exception if the feature does not describe the specified time     */    public void setScore(String featureName,int time,float interest) throws Exception{	Feature currentFeature=null;	int index=0;	for(;index<features.size();index++) {	    currentFeature=(Feature)features.elementAt(index);	    //if(found the correct feature):	    if(featureName.equals(currentFeature.getFeatureName())) {		//Set the interest on that feature at the given time:		currentFeature.setScore(time,interest);		index=2*features.size();	//Stop the loop	    }	}	//Nothing found:	if(index==features.size()) {	    //This a new feature...	    //May generate an exception:	    features.addElement(new Feature(featureName,(TemporalMediaBlock)this,time,interest));	}    }        /**	Set score of named feature, at given time      *	@param	featureName the name of the feature to set     *	@param	time the time in milliseconds at which to set this score     *	@param	interestGaussian the gaussian distribution of interest scores     *	@exception	Exception if the feature does not describe the specified time     */    public void setScore(String featureName,int time,Gaussian interestGaussian) throws Exception{	Feature currentFeature=null;	int index=0;	for(;index<features.size();index++) {	    currentFeature=(Feature)features.elementAt(index);	    //if(found the correct feature):	    if(featureName.equals(currentFeature.getFeatureName())) {		//Set the interest on that feature at the given time:		currentFeature.setScore(time,interestGaussian);		index=2*features.size();	//Stop the loop	    }	}	//Nothing found:	if(index==features.size()) {	    //This a new feature...	    //May generate an exception:	    features.addElement(new Feature(featureName,(TemporalMediaBlock)this,time,interestGaussian));	}    }        /**	Using the features and the defined algorithm select the most interesting section of video     */    public void findMostInterestingSequence() {	try { 		//System.out.println(((Feature)features.firstElement()).divide(0f));	    	Feature[] featureArray= {getFeature("Frame Breaks"),getFeature("Vertical Motion"),getFeature("Goal Posts"),getFeature("Pitch")};	    		System.out.println("MOST INTERESTING SEQUENCE...");				//Feature mostInterestingSequence=(new Equation()).equals("+(Frame Breaks,50)",featureArray);		Feature mostInterestingSequence=(new Equation()).equals(Properties.summaryEquation,featureArray);		features.addElement(mostInterestingSequence);		pruneLongestInterestingPeriod(mostInterestingSequence);		System.out.println(mostInterestingSequence.toString());	}	catch(Exception e) {	    System.out.println("findMostInterestingSequence:	" + e.toString());	}    }        /**	Returns the feature by name     * 	@param	featureName the name of feature to return     * 	@return	The Feature with this name     * 	@exception	Exception if there is no such recorded feature by that name     */    public Feature getFeature(String featureName) throws Exception {	Feature result=null;		Feature currentFeature=null;	int index=0;	//for(all features):	for(;index<features.size();index++) {		currentFeature=getFeatureN(index);		//if(found feature with specified name):		if(featureName.equals(currentFeature.getFeatureName())) {		    index=2*features.size();		}	}		//if(feature not found):	if(index==features.size()) throw new Exception("No such feature " + featureName);	else {	    //Set result to found feature:	    result=currentFeature;	}		return(result);    }        /**	Return the nth Feature     * 	@param	n the nth Feature to get     * 	@return	the nth Feature     * 	@exception	ArrayIndexOutOfBoundsException if this n does not refer to a Feature     */    public Feature getFeatureN(int n) throws ArrayIndexOutOfBoundsException {	return((Feature)features.elementAt(n));    }        /**	Return the number of features measured     * 	@return	the number of features measured     */    public int getNumberOfFeatures() {	return(features.size());    }        /**	Get the amount of time (milliseconds) assigned to each element of scores array     * 	@return	the amount of time (milliseconds) assigned to each element of scores array     */    public float getTimePerElement() {	int numberOfElements=(int)((periodOfMedia.getDuration()/1000)*getSampleRate());		float timePerElement=((float)periodOfMedia.getDuration())/((float)numberOfElements);		return(timePerElement);    }        /**	For a given index return the associated time in milliseconds     * 	@param	index index at which time required     * 	@return	The time associated with this index in milliseconds     * 	@exception	Exception if this index specifies a time not within this feature     */    public int getTimeOfIndex(int index) throws Exception{	int timeOfIndex=(int)(periodOfMedia.getStart()+(getTimePerElement()*((float)index)));		if(index<0 || timeOfIndex>periodOfMedia.getFinish()) {	    throw new Exception("Index, " + index + ", is not recorded by this feature");	}		return(timeOfIndex);    }        /**	Get the index for the given time in milliseconds     *	@param	time time in milliseconds to get associated index for     *	@return	the index for the given time in milliseconds     *	@exception	Exception if specified time is not within this feature     */    public int getIndexOfTime(int time) throws Exception{	int index=0;	int relativeTime=time-periodOfMedia.getStart();		if(relativeTime<0 || time>periodOfMedia.getFinish()) {	    throw new Exception("Time, " + time + ", is not recorded by this feature");	}		return(index);    }        /**	Get the overall score for all these features at the specified time      *	@param	time the time in milliseconds for which the score is requested     *	@return	the overall score for all these features at the specified time     *	@exception	Exception if specified time is not within these features     *	CURRENTLY UNIMPLEMENTED     */    public float getScoreAtTime(int time) throws Exception{	return(getScoreAtIndex(getIndexOfTime(time)));    }        /**	Get the overall score for all these features at the specified index      *	@param	index the index at which the score is requested     *	@return	the overall score for all these features at the specified index     *	@exception	Exception if the index specifies a time is not within these features     *	CURRENTLY UNIMPLEMENTED     */    protected float getScoreAtIndex(int index) throws IndexOutOfBoundsException{	//Calculate score dynamiclly from features and algorithm	return(0f);    }        /**	Get a string representation of this object     *	@return	the string representation of this object     */    public String toString() {	String stringToReturn=new String();		Feature currentFeature=null;	//for(each feature):	for(int index=0;index<features.size();index++) {	    currentFeature=(Feature)features.elementAt(index);	    //Get it as a string:	    stringToReturn+=currentFeature.toString();	}		return(stringToReturn);    }        /**	Using the interest information prune the timeline to include only the most interesting events     *	@param	feature the Feature from whicht o obtain the longest interesting period     */    public void pruneLongestInterestingPeriod(Feature feature) {	int firstIndexOfLongestSequence=0;	int lastIndexOfLongestSequence=0;		int firstIndex=0;	int lastIndex=0;		Feature summary=new Feature("Summary",feature);		//for(each data point in the feature):	for(int index=0;index<feature.getNumberOfElements();) {	    //if(score is above threshold for true):	    if(feature.getBoolAtIndex(index)) {		firstIndex=index;				do {		    lastIndex=index;		    index++;		} while(index<feature.getNumberOfElements() && feature.getBoolAtIndex(index));		//while(more points to get AND score is true):				//Is this the longest sequence seen so far?		if((lastIndex-firstIndex)>(lastIndexOfLongestSequence-firstIndexOfLongestSequence)) {		    firstIndexOfLongestSequence=firstIndex;		    lastIndexOfLongestSequence=lastIndex;		}	    }	    else {		index++;		    }	}			for(int index=firstIndexOfLongestSequence;index<lastIndexOfLongestSequence+1;index++) {		try {	    		summary.setConfidence(1f,index); 		}		catch(Exception e) {		    //Couldn't set the confidience at that index - should never be thrown		}	}	features.addElement(summary);		//Create a feature which is the summarised clip alone:	try {		summarisedPeriod=new Period(getTimeOfIndex(firstIndexOfLongestSequence),					    getTimeOfIndex(lastIndexOfLongestSequence));		}	catch(Exception e) {	    	//Couldn't calculate the summarised period - should never be thrown	    	System.out.println("Couldn't set summarisedPeriod	" + e.toString());	}    }        /**	Get the summarised period     * 	@return a Period which represents the summarised clip     * 	@exception Exception if the summarised period has not been calculated     */    public Period getSummarisedPeriod() throws Exception {	Period result=summarisedPeriod;	if(result==null) throw new Exception("The summarised period has not been calculated");		return(result);    }}