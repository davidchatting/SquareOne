//7th January 2000package uk.ac.bham.cs.djc.time;import java.util.Vector;import java.io.Serializable;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.IOException;import java.net.URL;import uk.ac.bham.cs.djc.mediaDescriptors.*;/**	A timeline<p> * 	 * 	<a href="TimeLine.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 7th January 2000 */public class TimeLine implements Serializable{    	/**	The class for which this is a timeline */    	protected String mediaBlockClass=null;		/**	The start times in this timeline */	protected Vector startTimes=new Vector();		/**	The stop times in this timeline */	protected Vector stopTimes=new Vector();		/**	Make a new TimeLine for this media block class	 * 	@param	newTemporalMediaBlock	 * 	@exception Exception	 */	public TimeLine(TemporalMediaBlock newTemporalMediaBlock) throws Exception{	    mediaBlockClass=(newTemporalMediaBlock.getClass()).getName();	    	    add(newTemporalMediaBlock);	}		/**	Copy constructor	 * 	@param	anotherTimeLine	 */	public TimeLine(TimeLine anotherTimeLine) {	    mediaBlockClass=new String(anotherTimeLine.mediaBlockClass);	    /*	    startTimes=(Vector)((anotherTimeLine.startTimes).clone());	    stopTimes=(Vector)((anotherTimeLine.stopTimes).clone());	    */	    	    /*	    startTimes=anotherTimeLine.startTimes;	    stopTimes=anotherTimeLine.stopTimes;	    */	    	    Moment currentMoment=null;	    for(int startIndex=0;startIndex<anotherTimeLine.startTimes.size();startIndex++) {		try {		    	currentMoment=(Moment)(anotherTimeLine.startTimes.elementAt(startIndex));			add(new TemporalMediaBlock(currentMoment.getTemporalMediaBlock()));		}		catch(Exception e) {		}	    }	}		/**	Get the media block class of which this is a timeline	 * 	@return	the media block class of which this is a timeline 	 */	public String getMediaBlockClass() {	    return(mediaBlockClass);	}		/**	 * 	@return	 */	public Vector getStartTimes() {	    return(startTimes);	}		/**	 * 	@return	 */	public Vector getStopTimes() {	    return(stopTimes);	}		/**	 * 	@param	n	 * 	@return	 */	public Period getPeriodN(int n) {	    return(getTemporalMediaBlockN(n).getPeriodOfMedia());	}		/**	 * 	@param	n	 * 	@return	 */	public TemporalMediaBlock getTemporalMediaBlockN(int n) {	    TemporalMediaBlock thisTemporalMediaBlock=((Moment)(startTimes.elementAt(n))).getTemporalMediaBlock();	    	    return(thisTemporalMediaBlock);	}		/**	 * 	@return	 */	public int numOfTemporalMediaBlocks() {	    return(numOfPeriods());	}		/**	 * 	@return	 */	public int numOfPeriods() {	    return(startTimes.size());	}		/**	Add a new media block to the timeline	 * 	Must be same class as the other media blocks in the timeline	 * 	@param	newTemporalMediaBlock	 * 	@exception	Exception if newTemporalMediaBlock is not an instance of the mediaBlock class	 */	public void add(TemporalMediaBlock newTemporalMediaBlock) throws Exception{	    //NEED MORE TO CHECK IF INSTANCE OF (SUB-CLASS):	    if(!mediaBlockClass.equals(newTemporalMediaBlock.getClass().getName())) {		//throw(new Exception("newTemporalMediaBlock is not an instance of " + mediaBlockClass));	    }	    	    addStartTime(newTemporalMediaBlock);	    addEndTime(newTemporalMediaBlock);	}		/**	Adds a new start time to the END of the startTimes vector	 * 	@param	newTemporalMediaBlock	 * 	@exception	Exception	 */	protected void addStartTime(TemporalMediaBlock newTemporalMediaBlock) throws Exception{	    Period newPeriod=newTemporalMediaBlock.getPeriodOfMedia();	    	    Moment newMoment=new StartMoment(newTemporalMediaBlock);	    Moment currentMoment=null;	    	    if(startTimes.size()==0) startTimes.addElement(newMoment);	    else {		int index=0;			    	do {			currentMoment=(Moment)startTimes.elementAt(index);			index++;	    	} while(newMoment.getValue()>currentMoment.getValue() && index<startTimes.size());				if(!(index<startTimes.size())) startTimes.addElement(newMoment);	    	else startTimes.insertElementAt(newMoment,index-1);	    }    	}		/**	Adds a new end time to the END of the endTimes vector	 * 	@param	newTemporalMediaBlock	 * 	@exception	Exception	 */	protected void addEndTime(TemporalMediaBlock newTemporalMediaBlock) throws Exception{	    Period newPeriod=newTemporalMediaBlock.getPeriodOfMedia();	    	    Moment newMoment=new StopMoment(newTemporalMediaBlock);	    Moment currentMoment=null;	    	    if(stopTimes.size()==0) stopTimes.addElement(newMoment);	    else {	    	int index=0;			    	do {			currentMoment=(Moment)stopTimes.elementAt(index);			index++;	    	} while(newMoment.getValue()>currentMoment.getValue() && index<stopTimes.size());				if(!(index<stopTimes.size())) stopTimes.addElement(newMoment);		else stopTimes.insertElementAt(newMoment,index-1);	    }	}		/**	Is this time on included on the timeline?	 * 	@param	time the time in tmilliseconds to test	 * 	@return	if this time on included on the timeline	 */	public boolean onTimeLine(Period time) {	    boolean result=false;	    	    //Can distinguish down to milliseconds:	    double sampleRate=1d/1000d;	    TemporalMediaBlock timeAsMediaBlock=new TemporalMediaBlock(time,sampleRate);	    	    try {	    	TimeLine timeAsTimeLine=new TimeLine(timeAsMediaBlock);	    	if(intersection(timeAsTimeLine)!=null) result=true;	    }	    catch(Exception e) {		//This exception should never be thrown - as generated only when more than one time in timeline	    }	    	    return(result);	}		/**	Generate the intersection of this timeline and a second	 * 	@param	secondTimeLine the other timeline with which to find the intersection	 * 	@return	the intersection of this timeline and secondTimeLine	 */	public TimeLine intersection(TimeLine secondTimeLine) {	    TimeLine timelineToReturn=null;	    TemporalMediaBlock commonTime=null;	    Vector otherStopTimes=secondTimeLine.getStopTimes();	    	    Moment currentStartMoment=null;	    Moment currentStopMoment=null;	    	    double lowestCommonSampleRate=0d;	    double sr1=(((Moment)startTimes.firstElement()).getTemporalMediaBlock()).getSampleRate();	    double sr2=(((Moment)otherStopTimes.firstElement()).getTemporalMediaBlock()).getSampleRate();	    lowestCommonSampleRate=Math.min(sr1,sr2);	    	    String descriptionOfIntersection=null;	    	    //for(each period in this start-times):	    for(int startIndex=0;startIndex<startTimes.size();startIndex++) {		//currentStartMoment=(Moment)stopTimes.elementAt(startIndex);		currentStartMoment=(Moment)startTimes.elementAt(startIndex);			    	//for(each period in the other stop-times with times after this start):	    	for(int stopIndex=0;stopIndex<otherStopTimes.size();stopIndex++) {		    try {		    	currentStopMoment=(Moment)otherStopTimes.elementAt(stopIndex);		    				TemporalMediaBlock thisTemporalMediaBlock=currentStartMoment.getTemporalMediaBlock();			TemporalMediaBlock otherTemporalMediaBlock=currentStopMoment.getTemporalMediaBlock();						String description1=thisTemporalMediaBlock.getDescription();			String description2=otherTemporalMediaBlock.getDescription();						descriptionOfIntersection=buildDescription(description1,description2);					    	commonTime=new TemporalMediaBlock((currentStartMoment.getPeriod()).getCommonPeriod(currentStopMoment.getPeriod()),							  lowestCommonSampleRate,							  descriptionOfIntersection);		    				URL externalResource=null;			if(getMediaBlockClass().equals("uk.ac.bham.cs.djc.mediaDescriptors.VideoBlock")) {			    try {			    	externalResource=thisTemporalMediaBlock.getExternalResource();			    }			    catch(Exception e) {				//Should be thrown as all VideoBlocks have externalReference			    }			}			if(secondTimeLine.getMediaBlockClass().equals("uk.ac.bham.cs.djc.mediaDescriptors.VideoBlock")) {			    try {			    	externalResource=otherTemporalMediaBlock.getExternalResource();			    }			    catch(Exception e) {				//Should be thrown as all VideoBlocks have externalReference			    }			}			commonTime.setExternalResource(externalResource);									if((commonTime.getPeriodOfMedia()).getDuration()>0) {				if(timelineToReturn==null) {	    				timelineToReturn=new TimeLine(commonTime);	    			}	    			else {	    				timelineToReturn.add(commonTime);		    			}			}		    }		    catch(Exception e) {		    }		}	    }	    	    return(timelineToReturn);	}		/**	Build a description from two other descriptions	 * 	Concatenate the two descriptions and deal with either being null	 * 		 * 	@param	description1 the first decription	 * 	@param	description2 the second decription	 * 	@return	the built description	 */	protected String buildDescription(String description1,String description2) {	    String descriptionOfIntersection=new String();	    if(description1!=null) {		descriptionOfIntersection+=description1;	    }	    if(description1!=null && description2!=null) {		descriptionOfIntersection+=System.getProperty("line.separator");	    }	    if(description2!=null) {		descriptionOfIntersection+=description2;	    }	    	    return(descriptionOfIntersection);	}	/**	Cut the periods in the timeline in two halves at this many milliseconds	 * 	@param	timeToCutAt the time at which to split the timeline, in milliseconds	 */	public void cut(int timeToCutAt) {	    //Search through start times where starts before or equal to this time	    //Search through stop times where stops after or equal to this time	    	    Moment currentMoment=null;	    Period currentPeriod=null;	    	    int startTimesSizeBeforeCuts=startTimes.size();	    	    //for(each period in this start-times):	    for(int index=0;index<startTimesSizeBeforeCuts;index++) {		currentMoment=(Moment)startTimes.elementAt(index);		currentPeriod=currentMoment.getPeriod();		double sampleRate=(currentMoment.getTemporalMediaBlock()).getSampleRate();				//If really equal no need to cut		if(currentPeriod.getStart()<timeToCutAt) {		    if(currentPeriod.getFinish()>timeToCutAt) {			//Cut this moment!			int newBlockFinish=currentPeriod.getFinish();			currentPeriod.setFinish(timeToCutAt);						try {			    	//Added to END of the vector so interating to startTimesSizeBeforeCuts will ignore these:				add(new TemporalMediaBlock(new Period(timeToCutAt,newBlockFinish),sampleRate));				index++;			}			catch(Exception e) {			    	//Try to limit the damage...			    	currentPeriod.setFinish(newBlockFinish);			}		    }		}	    }	    	    //Change end times of intersection and create new times for second half	}		/**	Print to System.out decriptions of all the periods in this timeline	 */	public void printDescriptions() {	    for(int index=0;index<startTimes.size();index++) {		System.out.println((((Moment)startTimes.elementAt(index)).getTemporalMediaBlock()).getDescription());	    }	}		/**	Generate a decription of this timeline as a string	 * 	@return the decription of this timeline as a string	 */	public String toString() {	    String stringToReturn=new String();	    	    stringToReturn+=System.getProperty("line.separator");	    stringToReturn+=getMediaBlockClass() + ":";	    stringToReturn+=System.getProperty("line.separator");	    stringToReturn+="Start Times: " + startTimes;	    stringToReturn+=System.getProperty("line.separator");	    stringToReturn+="Stop Times: " + stopTimes;	    	    return(stringToReturn);	}		/**	Write TimeLine object to a stream	 * 	@param	out the stream to which the object is written	 */	private void writeObject(ObjectOutputStream out) throws IOException {	    out.defaultWriteObject();    	}		/**	Read TimeLine object from the stream	 * 	@param	in the stream from which to read the object	 */	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {	    in.defaultReadObject();	}}