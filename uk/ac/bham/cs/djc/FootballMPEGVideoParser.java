//11th February 2000 - DJCpackage uk.ac.bham.cs.djc;import uk.ac.bham.cs.djc.MPEG_Play.*;import java.io.InputStream;import de.tuchemnitz.informatik.MPEG_Play.io_tool;import de.tuchemnitz.informatik.MPEG_Play.MPEG_Play;import java.net.URL;import quicktime.QTSession;import quicktime.std.movies.media.DataRef;import quicktime.std.movies.Movie;import quicktime.std.StdQTConstants;import quicktime.QTException;import java.awt.Point;import java.util.Vector;import uk.ac.bham.cs.djc.time.TimesOfInterest;import uk.ac.bham.cs.djc.time.TimeLine;/**	Parser of MPEG video of football matches<p> * 	 * 	<a href="FootballMPEGVideoParser.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 11th February 2000 */public class FootballMPEGVideoParser extends MPEG_video {    /**	The location of the football movie to parse */    protected URL movieLocation=null;        /**	Vector of recent values for vertical motion scores */    protected Vector recentValues=new Vector();        /**	The value of the last frame's vertical motion */    private int lastVerticalMotion=0;         /**	Constructor */    public FootballMPEGVideoParser(MPEG_Play play, io_tool tool, URL newMovieLocation, int startTimeOfVideo){	super(play,tool,newMovieLocation,startTimeOfVideo);	movieLocation=newMovieLocation;	//System.out.println("FootballMPEGVideoParser()");    }        /**	Parse a subsequence of the video    *	sequenceToParse - Timeline object describing the sequence to parse    */    public void parseSequence(TimesOfInterest sequenceToParse) {	super.parseSequence(sequenceToParse);    }        /**	Parse the current frame     * extends Parse_picture() in uk.ac.bham.cs.djc.MPEG_Play.MPEG_video     */    protected void Parse_picture() {    	//Parse ths picture using MPEG decoder:	super.Parse_picture();		//if(this GOP (Group of Pictures) is being parsed):	if(PARSE_THIS_GOP && currentFrame!=null) {	    //currentFrame.show();	    	    //Get image data:	    FootballImageParser pixelData=currentFrame.getPixelData();	    	    try {		//Calculate interest based on inter-frame disimilarity (frame breaks):	    	float rb=currentFrame.getRb();		//int interest=(int)((Math.log((double)rb)/(Math.log((double)currentFrame.getNumberOfBackwardMacroblocks())))*100d);		float interest=rb/((float)currentFrame.getNumberOfBackwardMacroblocks());				//Filter out the noise:		if(interest<0.10) interest=0f;				//interest/=Properties.ratioForFrameBreak;		if(interest>1) interest=1;				if(interest>0) {			int time=(currentFrame.getPeriodOfMedia()).getStart();						//Set interest gaussian with a width of 4 seconds:			//((TimesOfInterest)cutList).setScore(new String("Frame Breaks"),time,new Gaussian(Properties.lengthOfInterestForFrameBreak,interest));			((TimesOfInterest)cutList).setScore(new String("Frame Breaks"),time,interest);		}	    }	    catch(Exception e) {		//Can't get Rb ratio on non-B frames	    }	    	    //Calculate total displacement of macroblocks - good indication of camera motion (in football)	    Point totalDisplacement=currentFrame.getTotalDisplacement();	    if(currentFrame.getFrameType()=='P') {	        System.out.println(currentFrame.getFrameNumber() + ": Total Displacement	:" + totalDisplacement);	    }	    else {		System.out.println(currentFrame.getFrameNumber() + ": Total Displacement	:");	    }	    	    //Calculate interest based on long periods of vertical motion from camera (tend to be behind goal shots):	    int x=totalDisplacement.x;	    int y=totalDisplacement.y;	    	    /*	    if(currentFrame.getFrameType()=='P') {	    	//If(more vertical motion than horizontal):	    	if(Math.abs(y)>Math.abs(x)) {		   //if(motion in same direction as previously)		   if((y*lastVerticalMotion)>=0) {		       	//Store this value in the recentValues vector:		   	setRecentValue((int)(0.03f*y));		   }		   else {		       //if(different direction than before):		       setInterestFromRecentValues();		       setRecentValue((int)(0.03f*y));		   }	    	}	    	else {			setInterestFromRecentValues();	    	}	     	    }	    */	    	    if(currentFrame.getFrameType()=='P') {		float interest=currentFrame.getPercentageOfVerticalMacroblocks();				//if(more than 50)%)		if(interest>0.5f) {		    	interest=(interest-0.5f)*2f;						//Clip:			//interest/=0.5f;			if(interest>1) interest=1;		    		    	int time=(currentFrame.getPeriodOfMedia()).getStart();			try {				((TimesOfInterest)cutList).setScore(new String("Vertical Motion"),time,new Gaussian(500,interest));			}			catch(Exception e) {			}		}	    }	    	    //if(an I-Frame, where picture data is immediately available):	    if(currentFrame.getFrameType()=='I') {	    	try {		    	//Does this image show a pitch?	    		if(pixelData.isPitch()) {			    //if so set interest gaussian with width of 300mS (approximates distance between I-frames):			    int time=(currentFrame.getPeriodOfMedia()).getStart();			    ((TimesOfInterest)cutList).setScore(new String("Pitch"),time,new Gaussian(600,1f));	    		}	    	}	    	catch(Exception e) {			//No pixel data available	    	}				try {		    //Does this image show goal posts?		    if(pixelData.areGoalPosts()) {			//if so set interest gaussian with width of 300mS (approximates distance between I-frames):			int time=(currentFrame.getPeriodOfMedia()).getStart();			((TimesOfInterest)cutList).setScore(new String("Goal Posts"),time,new Gaussian(900,1f));		    }		}		catch(Exception e) {		    //System.out.println(e);		}		    }	}    }        /**	Set the interest of these recent values,      * which is proportionate to number of recent values     */    protected void setInterestFromRecentValues() {	Point currentReading=null;	//for(each recent value):	for(int index=0;index<recentValues.size();index++) {		currentReading=(Point)recentValues.elementAt(index);		int time=currentReading.x;		int interest=Math.abs(currentReading.y)*recentValues.size();				try {			((TimesOfInterest)cutList).setScore(new String("Vertical Motion"),time,new Gaussian(1000,interest));		}		catch(Exception e) {		}		//((TimesOfInterest)cutList).setInterest(time,interest);		//System.out.println("time:	" + time + " interest:	" + interest);	}		recentValues.removeAllElements();	lastVerticalMotion=0;    }        /**	Add a value to the list of recent values     * 	y - value to add     */    private void setRecentValue(int y) {	Point time_y=new Point(((currentFrame.getPeriodOfMedia()).getStart()),y);	recentValues.addElement(time_y);	lastVerticalMotion=y;    }        /**	Get the diuration of the video track in milliseconds     * 	Throws Exception if unable to obtain duration     */    public int getDuration() throws Exception{	String theURL=movieLocation.toString();		int startTime=0;	int stopTime=0;	//QT class don't work properly if url specified in file:/myDirectory/myMovie.mpg	//So transform to file:///myDirectory/myMovie.mpg format	if(theURL.startsWith("file:/")) {	    if(!theURL.startsWith("file://")) {		theURL=((new StringBuffer(theURL)).insert(5,"//")).toString();	    }	}		try {	    QTSession.open();	    	    // create the DataRef that contains the information about where the movie is	    DataRef urlMovie = new DataRef(theURL);	    	    // create the movie and get the stop time:	    Movie m = Movie.fromDataRef(urlMovie,StdQTConstants.newMovieActive);	    stopTime=((m.getDuration()*1000)/m.getTimeScale());	}	catch (QTException err) {	    //System.out.println("QTException: " + err);	    QTSession.close ();	    throw new Exception("Can't get duration of :" + theURL);	}	QTSession.close ();		return(stopTime-startTime);    }}