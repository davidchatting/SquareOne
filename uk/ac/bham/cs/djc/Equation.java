//Created 11th March 2000 - DJCpackage uk.ac.bham.cs.djc;import java.util.Vector;import uk.ac.bham.cs.djc.time.Feature;/**	 * 	 * 	<a href="Equation.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 11th March 2000 */public class Equation{    /**	The features available for use in the equation */    protected Feature[] features=null;        /**	Evaluate this equation     * 	@param	prefixEquation	the equation to evaluate written in prefix notation, e.g. operation(operand1,operand2)     * 	@param	newFeatures features avaiable for use in the equation     * 	@exception Exception if the specified equation can not be created     * */    public Feature equals(String prefixEquation,Feature[] newFeatures) throws Exception {	features=newFeatures;		//Create parse tree from the prefix equation:	Node equation=(Node)parse(prefixEquation);		//Return the result of evaluating this equation:	return((Feature)equation.evaluate());    }        /**	Parse the expression in prefix notation     *	@param	subexpression expression in prefix notation to parse    *	@return	the result of parsing this subexpression    *	@exception Exception if this subexpression can't be parsed    */    protected Object parse(String subexpression) throws Exception{	Object result=null;		//Get the operation from the front of the expression:	String operation=getFirstOperator(subexpression);		//Remove operator from the front of the expression:	subexpression=subexpression.substring(operation.length());		//Strip a single pair of brackets from each end of the equation:	subexpression=stripBrackets(subexpression);		//Get the arity of this operation and make array to hold them:	int arity=getArity(operation);	String[] operands=new String[arity];		//For(each operand expected):	for(int a=0;a<arity;a++) {	    try {		//Add the subexpression into the operand array:		operands[a]=getFirstOperand(subexpression);				//Remove operand from the front of the expression:	    	subexpression=subexpression.substring(operands[a].length()+1);	    }	    catch(Exception e) {		//Exception from getFirstOperand() or StringIndexOutOfBoundsException from substring()	    }	}		//Set the root object:	Object root=null;	if(operation.length()==1) root=new Character(operation.charAt(0));	else root=operation;	result=new Node(root);		//For(each operand):	for(int a=0;a<arity;a++) {	    try {		//Throws exception if operand is leaf (in terminal set):	    	if(a==0) ((Node)result).addLHS(parse(operands[a]));		else if(a==1) ((Node)result).addRHS(parse(operands[a]));	    }	    catch(Exception e) {		//Can't parse anymore...	    	try {		    //Throws exception if operands[a] is not a known feature:	    	    Feature thisFeature=featureWithThisName(operands[a]);		    if(a==0) ((Node)result).addLHS(thisFeature);		    else if(a==1) ((Node)result).addRHS(thisFeature);	    	}	    	catch(Exception e2) {		    try {			//Throws exception if operands[a] is not a float:			Float thisFloat=new Float(operands[a]);			if(a==0) ((Node)result).addLHS(thisFloat);		    	else if(a==1) ((Node)result).addRHS(thisFloat);		    }		    catch(NumberFormatException nfe) {			//Add operands[a] to the tree:			if(a==0) ((Node)result).addLHS(operands[a]);		    	else if(a==1) ((Node)result).addRHS(operands[a]); 		    }  	    	}	    }	}	return(result);    }        /**	Get the first substring from this string ending in a specified character     *	@param	endChar the character which ends the substring    *	@param	prefixEquation the string from which the substring originates    *	@return	the first substring from this string ending in endChar     *	@exception	Exception if the end character is not in this string    */    protected String getSubstringEndingIn(char endChar,String prefixEquation) throws Exception{	String result=null;		//Find the index of the end character:	int endIndex=prefixEquation.indexOf(endChar);	if(endIndex==-1) throw new Exception("Can't find " + endChar + "in " + prefixEquation);				    			//Get the substring:	result=prefixEquation.substring(0,endIndex);					    	return(result);    }        /**	Get the first operand in this string     * 	@param	prefixEquation string in which the operand is to be found     * 	@return	the first operand in this string     * 	@exception	Exception if an operand can not be found in this string     */    protected String getFirstOperand(String prefixEquation) throws Exception{	String result=null;		int openBrackets=0;	int closeBrackets=0;		//for(each character in the prefixEquation):	for(int i=0;i<prefixEquation.length() && result==null;i++) {	    char currentChar=prefixEquation.charAt(i);	    	    //Count open and closed brackets:	    if(currentChar=='(') openBrackets++;	    else if(currentChar==')') closeBrackets++;	    	    //if(find a non-nested ","):	    else if(currentChar==',' && openBrackets==closeBrackets) {		result=prefixEquation.substring(0,i);	    }	}	//This prefixEquation is a string in the terminal set:	if(result==null) result=prefixEquation;		return(result);    }        /**	Get the first operator in this string     * 	@param	prefixEquation the string in which the operator is to be found     * 	@return the first operator in this string or prefixEquation if no operand is found     * 	@exception	Exception     */    protected String getFirstOperator(String prefixEquation) throws Exception{	//The operator is the string before the "(":	return(getSubstringEndingIn('(',prefixEquation));    }        /**	Get the feature object with this name from the list of known features     *	@param	featureName name of the feature to retrieve     *	@return	the Feature with the specified name     *	@exception Exception if there is no feature with this name     */    protected Feature featureWithThisName(String featureName) throws Exception{	Feature result=null;       	       	//for(each feature in the features vector - while no mtching feature is found):	for(int index=0;index<features.length && result==null;index++) {	       //if(this feature's name is the same as the target features name):	       if((features[index].getFeatureName()).equals(featureName)) {	       		//Assign this as result:	       		result=features[index];	       }	}	//if(no result found):	if(result==null) throw new Exception("No feature available of name " + featureName);		return(result);    }	           /**	Strip a pair of backets from the start and end of the string     * This process is destructive     *	@param	prefixEquation the string from which to remove the brackets     *	@exception	Exception if pair of brackets not found to strip     */    protected String stripBrackets(String prefixEquation) throws Exception{    	String result=null;    		//if(brackets at te begining and end of the string):	if(prefixEquation.startsWith("(") && prefixEquation.endsWith(")")) {	       //Remove brackets:	       result=prefixEquation.substring(1,prefixEquation.length()-1);    	}	//Throw exception if pair of brackets not found:    	else throw new Exception("Excepted balanced brackets, got " + prefixEquation);		return(result);    }	           /**	Get the arity of this operator     *	@param	symbol - the operator to get the arity of     *	@return Currently always returns 2, regardless     */	           protected int getArity(String symbol) {	return(2);    }}