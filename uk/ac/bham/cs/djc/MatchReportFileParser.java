//20th November 1999 - DJCpackage uk.ac.bham.cs.djc;import java.io.*;import java.util.StringTokenizer;import java.net.URL;import java.net.URLConnection;import java.util.Hashtable;import uk.ac.bham.cs.djc.mediaDescriptors.TextualEventDescriptor;import uk.ac.bham.cs.djc.time.Period;/**	Parsed a textual match report, such as those to be found in a newspaper<p> * 	 * 	<a href="MatchReportFileParser.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 20th November 1999 */public class MatchReportFileParser extends MatchReportFile{    	/**	Interesting event phrases */    	protected static String[] eventPhases=	{"goal","scored","free kick","free-kick","sent off","send off","sending off"};    	//protected static String[] timePhases=	{"minute","half","time","full-time","kick-off"};		/**	Phrases which relate to a specific point in the match, eg half-time=45 mins (approx) */	protected static Hashtable timePhrasesHashTable=null;		/**	Exceptions to the th-rule for generating nth pharses for a number, eg first not oneth */	protected static Hashtable nthPhrasesExceptions=null;		/**	Array of numbers written as words, where index is the numberical value represented */	protected static String[] numberAsWord=	{"zero","one","two","three","four","five","six","seven","eight","nine",						"ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};		/**	Hashtable built from numberAsWord array */	protected static Hashtable numberAsWordHashtable=null;		/**	Phrases which refer to an evnt happening before another */	protected static String[] lessThanPhases = {"from","before"};		/**	Phrases which refer to an evnt happening after another */	protected static String[] greaterThanPhases = {"after","into"};		/**	Hashtable built of relative phrases (both before and after) */	protected static Hashtable relativePhasesHashtable=null;		/**	Constructor	 * 	newLocation - location of match report file	 * 	Throws IOException if unable to open file	 */	public MatchReportFileParser(URL newLocation) throws java.io.IOException{	    this(newLocation,new String());	}		/**	Constructor	 * 	newLocation - location of match report file	 * 	Throws IOException if unable to open file	 */	public MatchReportFileParser(URL newLocation,String newOptions) throws java.io.IOException{		super(newLocation,newOptions);				//Try to open match report file (might throw IOException):		URLConnection thisConnection = newLocation.openConnection();        	DataInputStream in = new DataInputStream(thisConnection.getInputStream());		BufferedReader d = new BufferedReader(new InputStreamReader(in));				String currentLine;		//Delimiter for sentence is ".":		String delimiters=new String(".");				TextualEventDescriptor event=null;        	try {		    	//for(each line in the file):            		while (true) {			    	//Get the next line:                		currentLine=d.readLine();								//Tokenise this line:				StringTokenizer st = new StringTokenizer(currentLine,delimiters,false);				//while(there are more tokens to parse):            			while (st.hasMoreTokens()) {				    	String sentence=st.nextToken();					String originalSentence=new String(sentence);									    	try {					    	//Get time from sentence (will often throw exception as no time available):						int timeIn_mSeconds=getTimeFromSentence(sentence)*60000;						//Create a new TextualEventDescriptor to describe this event (one minute either side of parsed time):						event=new TextualEventDescriptor(originalSentence,new Period((timeIn_mSeconds-60000),(timeIn_mSeconds+60000)));												//Add to list of media blocks found in this report:						addMediaBlock(event);					}					catch(Exception e) {					    	//Couldn't extract a time from the sentence					}            			}            		}        	} catch (Exception e) {		    //Will get Null-pointer exception when there are no more lines left        	}					in.close();	}		/**	Given a setence try to extract the time (in minutes) 	 *	sentence - sentence to parse time from	 *	Throws NumberFormatException if no recognised time phrases available	 */	public int getTimeFromSentence(String sentence) throws NumberFormatException{	    	int time=-1;	    		    	sentence=sentence.toLowerCase();				int firstIndexOfMinuteString=sentence.indexOf("minute");				//if(the word "minute" is found):		if(firstIndexOfMinuteString!=-1) {		    	//if(there is a word in front of minute):			if(firstIndexOfMinuteString-2>=0) {			    	//Go to the first character of the previous word:			    	int n=firstIndexOfMinuteString-2;			    	while(n>0 && sentence.charAt(n)!=' ') n--;				if(sentence.charAt(n)==' ') n++;		    				//Extract the number string from the sentence:		    		String numberString=sentence.substring(n,firstIndexOfMinuteString-1);					//Try to find time from figure (including 'st,'nd and 'th) or number as word,				//	May throw NumberFormatException:				time=getNthMinuteFromWord(numberString);								//if of the form:	"MINUTE PHRASE" + "EQUALITY PHRASE" + "EVENT PHRASE", eg "2 minutes after half-time"				try {					//if time phrase parsed without exception:				    					    	//Get index of word following the word "minute":				    	int index=firstIndexOfMinuteString+(getNextWord(sentence.substring(firstIndexOfMinuteString))).length()+1;										//Try to get offset phrase (eg before or after),					//	may throw Exception:					time*=getOffset(sentence.substring(index));										//if offset phrase found without exception:											//Try to get event which the previous phrase is relative to (eg full time=90 mins approx),					//	may throw Exception:					index=index+(getNextWord(sentence.substring(index))).length()+1;					time=getTimeFromPhrase(getNextWord(sentence.substring(index)))+time;				}				catch(Exception e2) {				    	//Not of form:	"MINUTE PHRASE" + "EQUALITY PHRASE" + "EVENT PHRASE"					//Not in any understood syntax => can't be sure of time					throw new NumberFormatException("Can't getTimeFromSentence() from " + sentence);				}			}		}		//If no time found:		if(time<0) throw new NumberFormatException("Can't getTimeFromSentence() from " + sentence);				return(time);	}		/**	Get either 1 or -1 for a string describe the relation between two events	 * 	Eg. 1 for after and -1 for before	 * 	offsetString - phrase to parse for offset	 * 	Throws Exception if unable to find know relative phrase	 */	protected int getOffset(String offsetString) throws Exception{	    int offset=0;	    	    //If necessary - build the hashtable of relaive phrases	    if(relativePhasesHashtable==null) {		relativePhasesHashtable = new Hashtable();				//All less than phrase have value of -1:		for(int index=0;index<lessThanPhases.length;index++) {		    	relativePhasesHashtable.put(lessThanPhases[index], new Integer(-1));		}				//All greater than phrase have value of 1:		for(int index=0;index<greaterThanPhases.length;index++) {		    	relativePhasesHashtable.put(greaterThanPhases[index], new Integer(1));		}	    }	    	    try {		int index=0;		//while(offsetString.charAt(index)!=' ') index++;		//index++;						//First character of the next word						if(index<offsetString.length()) {			//if(this phrase is included in hashtable) get value:			Integer number=(Integer)relativePhasesHashtable.get(getNextWord(offsetString.substring(index)));			if(number!=null) {				offset=number.intValue();			}			}	    }	    catch(StringIndexOutOfBoundsException sobe) {		//Couldn't match phrase	    }	    //If no recognised phases found throw exception:	    if(offset==0) throw new Exception("Can't find sign of offset in " + offsetString);	    	    return(offset);	}		/**	Given a sentence get and return the next word in that sentence	 * 	For example for:	"Red lorry, yellow lorry" returns "Red"	 * 				"-==The man on the moon" returns "The"	 * 	sentence - the sentence from which to get the next word	 */	protected static String getNextWord(String sentence) {	    int index=0;	    int start=0;	    int end=0;	    	    //while(there are letter or digit characters) move along sentence:	    while(!Character.isLetterOrDigit(sentence.charAt(index))) index++;	    start=index;	//Record start of word	    	    //while(there are non letter or digit characters) move along sentence:	    while(Character.isLetterOrDigit(sentence.charAt(index))) index++;	    end=index;		//Record end of word	    	    //Get and return tthe substring which is the next word:	    return(sentence.substring(start,end));	}		/**	Get a time (in minutes) from this word	 * 	Eg, 12 will be return for 12, tweleve,12th or tweleveth	 * 	numberAsString - the string from which to obtain the number	 * 	Throws NumberFormatException if numberAsString is not parsable	 */	public int getNthMinuteFromWord(String numberAsString) throws NumberFormatException{	    int intToReturn=-1;	    	    try {		//Try to find either 12 or 12th,		//	throws NumberFormatException if can't	        intToReturn=getIntegerFromWord(numberAsString);	    }	    catch(NumberFormatException nfe){		//Build hashtable of exceptions to nth phrases rule:	    	if(nthPhrasesExceptions==null) {		    	nthPhrasesExceptions=new Hashtable();			nthPhrasesExceptions.put("first", new Integer(1));			nthPhrasesExceptions.put("second", new Integer(2));			nthPhrasesExceptions.put("third", new Integer(3));			nthPhrasesExceptions.put("fifth", new Integer(5));			nthPhrasesExceptions.put("eighth", new Integer(8));			nthPhrasesExceptions.put("ninth", new Integer(9));	    	}	    		    	Integer number=null;	    	number=(Integer)nthPhrasesExceptions.get(numberAsString);	    		    	if(number==null) {		    	//if(phrase not on list of nthPhrasesExceptions):			if(numberAsString.endsWith("ieth")) {			    	//'eith word (eg twenteith):			    	try {				    //Try removing the "eith" and add "y",				    //then look in list of numbers as words				    intToReturn=getWrittenWordAsNumber((numberAsString.substring(0,numberAsString.length()-4))+"y");			    	}				catch(NumberFormatException nfe2) {				    //Couldn't replace 	"eith" with "y" to make valid number				}			}					//if(still haven't found a time):			if(intToReturn<0) {			    	try {				    //Try to strip of th, rd or st,				    //to get integer or integer as word:				    intToReturn=getIntegerFromWord(numberAsString.substring(0,numberAsString.length()-2));			    	}			    	catch(NumberFormatException nfe3) {				    //Couldn't replace last two characters to make valid number				}			}	    	}	    	else {		    	//if(phrase is on list of nthPhrasesExceptions):			intToReturn=number.intValue();	    	}	    }	    //Couldn't get valid number:	    if(intToReturn<0) throw new NumberFormatException("Can't getNthMinuteFromWord() from " + numberAsString);	    	    return(intToReturn);	}		/**	For a written number return integer value	 * 	Eg. for twelve return 12	 * 	word - word to parse	 * 	Throws NumberFormatException if word can't be parsed	 */	public static int getWrittenWordAsNumber(String word) throws NumberFormatException{	    int intToReturn=-1;	    	    //Make numberAsWordHashtable if necessary:	    if(numberAsWordHashtable==null) {		numberAsWordHashtable = new Hashtable();				//Index in numberAsWord array is integer equivalent:		for(int index=0;index<numberAsWord.length;index++) {		    	numberAsWordHashtable.put(numberAsWord[index], new Integer(index));		}	    }	    	    //Look up word in hastable:	    Integer number=(Integer)numberAsWordHashtable.get(word);	    if(number!=null) intToReturn=number.intValue();	    	    //Throw exception if word is not found:	    if(intToReturn<0) throw new NumberFormatException("Can't getWrittenWordAsNumber() from " + word);	    	    return(intToReturn);	}		/**	For a number as a string return integer value	 * 	Eg. for "twelve" and "12" return 12	 * 	word - word to parse	 * 	Throws NumberFormatException if word can't be parsed	 */	protected int getIntegerFromWord(String word) throws NumberFormatException{	    int intToReturn=-1;	    	    try {		//Word written in figures:	    	intToReturn=Integer.parseInt(word);	    	if(intToReturn<0) intToReturn=-1;	    }	    catch(NumberFormatException nfe) {		//Word written in words:		try {		    intToReturn=getWrittenWordAsNumber(word);		}		catch(NumberFormatException nfe2) {		}	    }	    	    //Integer can't be parsed from word:	    if(intToReturn<0) throw new NumberFormatException("Can't getIntegerFromWord() from " + word);	    	    return(intToReturn);	}		/**	For a phrase get the associated time (in minutes)	 * 	Eg. for "full-time" return 90	 * 	phrase - phrase to parse	 * 	Throws NumberFormatException if phrase can't be parsed	 */	public static int getTimeFromPhrase(String phrase) throws NumberFormatException{	    int time=0;	    	    //Build timePhrasesHashTable if necessary:	    if(timePhrasesHashTable==null) {		timePhrasesHashTable=new Hashtable();				timePhrasesHashTable.put("kick-off", new Integer(0));		timePhrasesHashTable.put("half-time", new Integer(45));		timePhrasesHashTable.put("full-time", new Integer(90));		timePhrasesHashTable.put("time", new Integer(90));	    }	    	    //Look up phrase in hashtable:	    Integer number=(Integer)timePhrasesHashTable.get(phrase);	    if(number!=null) time=number.intValue();	    	    //Throw NumberFormatException if phrase can't be parsed:	    else throw new NumberFormatException("The phrase " + phrase + " is not recognised as a time");	    	    return(time);	}}