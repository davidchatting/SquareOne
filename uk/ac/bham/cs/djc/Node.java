//11th March 2000package uk.ac.bham.cs.djc;import java.util.Vector;import uk.ac.bham.cs.djc.time.Feature;/**	Node in internal representation of equation * 	Max. arity is implicity two <p> * 	 * 	<a href="MediaFile.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 11th March 2000 */public class Node{    /**	The node's root */    protected Object root=null;    /**	Left handside of the node */    protected Object lhs=null;    /**	Right handside of the node */    protected Object rhs=null;        /**	Constructor     * 	newRoot - the root of this new node     */    public Node(Object newRoot) {	root=newRoot;    }        /**	Constructor     * 	newRoot - the root of this new node     * 	newLHS - the left handside of this node     * 	newRHS - the right handside of this node     */    public Node(Object newRoot, Object newLHS, Object newRHS) {	this(newRoot);	addLHS(newLHS);	addRHS(newRHS);    }        /**	Add an object to the left handside of this node     * 	newLHS - object to add on the left handside     */    public void addLHS(Object newLHS) {	lhs=newLHS;    }       /**	Add an object to the right handside of this node     * 	newRHS - object to add on the right handside     */    public void addRHS(Object newRHS) {	rhs=newRHS;    }        /**	Evaluate this node and any children it may have     */    public Object evaluate() throws Exception{	Object result=null;		//If there are no children => value is just the root	if(lhs==null && rhs==null) {	    result=root;	}	//else there are children:	else {	    //Evaluate LHS:	    Object evaluationOfLHS=null;	    if(lhs!=null){	        if(lhs instanceof Node) evaluationOfLHS=((Node)lhs).evaluate();		else if(lhs instanceof Float) evaluationOfLHS=(Float)lhs;		else if(lhs instanceof Feature) evaluationOfLHS=(Feature)lhs;	    }	    	    //Evaluate RHS:	    Object evaluationOfRHS=null;	    if(rhs!=null){	        if(rhs instanceof Node) evaluationOfRHS=((Node)rhs).evaluate();		else if(rhs instanceof Float) evaluationOfRHS=(Float)rhs;		else if(rhs instanceof Feature) evaluationOfRHS=(Feature)rhs;	    }	    	    //Using values of LHS and RHS operate on them in the way specified by the root	    if(root instanceof Character) {		//Chars are +,-,/ and *, all 2-arity		char rootChar=((Character)root).charValue();				if(evaluationOfLHS instanceof Feature) {		    Feature lhsFeature=(Feature)evaluationOfLHS;		    		    if(evaluationOfRHS instanceof Float) {			float rhsFloat=((Float)evaluationOfRHS).floatValue();			result=lhsFeature.operate(rhsFloat,rootChar);		    }		    else if(evaluationOfRHS instanceof Feature) {			Feature rhsFeature=(Feature)evaluationOfRHS;			result=lhsFeature.operate(rhsFeature,rootChar);		    }		}	    }	    else if(root instanceof String) {		//Strings are mean and sum, all 1-arity		String rootString=(String)root;				if(evaluationOfLHS instanceof Feature) {		    Feature lhsFeature=(Feature)evaluationOfLHS;		    result=new Float(lhsFeature.operate(rootString));		}		//Ignore RHS as 1-arity	    }	    else {		//Matched nothing	    }	}		return(result);    }        /**	Return a string repreentation of this node     */    public String toString() {	String stringToReturn=new String();	stringToReturn+="ROOT:	" + root.toString() + " (" + root.getClass().getName() + ")";	stringToReturn+="	";	stringToReturn+="LHS:	" + lhs.toString() + " (" + lhs.getClass().getName() + ")";	stringToReturn+="	";	stringToReturn+="RHS:	" + rhs.toString() + " (" + rhs.getClass().getName() + ")";		return(stringToReturn);    }}