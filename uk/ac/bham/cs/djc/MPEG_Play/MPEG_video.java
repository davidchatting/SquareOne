//9th December 1999package uk.ac.bham.cs.djc.MPEG_Play;import de.tuchemnitz.informatik.MPEG_Play.*;import uk.ac.bham.cs.djc.time.Period;import uk.ac.bham.cs.djc.mediaDescriptors.VideoBlock;import uk.ac.bham.cs.djc.time.TimeLine;import uk.ac.bham.cs.djc.RGB_pixel;import java.awt.image.DirectColorModel;import java.net.URL;         /**	Selectively parse an MPEG-1 video stream * 	 * 	<a href="MPEG_video.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 9th December 1999 */public class MPEG_video extends de.tuchemnitz.informatik.MPEG_Play.MPEG_video{    	/**	The currently parsed frame */    	protected MPEG_frame currentFrame=null;		/**	The last I frame parsed */	protected MPEG_frame lastIFrame=null;		/**	The last P frame parsed */	protected MPEG_frame lastPFrame=null;		/**	The last B frame parsed */	protected MPEG_frame lastBFrame=null;		/**	The number of frames parsed so far */	protected int numberOfFramesParsed=0;		/**	The frame rates possible in MPEG video, in frames per second */	protected final double frameRates[]={1.0, 23.976, 24.0, 25.0, 29.97, 30.0, 50.0 ,59.94, 60.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};    		/**	END CODE defined by ISO 11172 */	protected static final int ISO_11172_END_CODE = 0x000001b9;		/**	The frame rate of this video */	protected double frameRate;		/**	If frames should be parsed */	protected boolean PARSE_FRAMES=false;		/**	If video information should be parsed */	protected boolean INFO_PARSED=false;		/**	If the current GOP should be parsed */	protected boolean PARSE_THIS_GOP=false;		/**	Where to parse */	protected TimeLine cutList=null;			/**	The time in the match when this video starts */	protected int startTimeOfVideo=0;		/**	The URL of this movie file */	protected URL movieFile=null;		/**	Create a new MPEG_video object	 * 	@param	play the MPEG_Play object used to display the movie (pass instance of MPEG_Play_null)	 * 	@param	stream	the MPEG stream	 * 	@param	newMovieFile the URL of the movie	 * 	@param	newStartTimeOfVideo the time in the match at which this video starts	 */	public MPEG_video(MPEG_Play play, io_tool stream,URL newMovieFile,int newStartTimeOfVideo) {	    this(play,stream,newMovieFile);	//THIS	    	    //Set the movie start time:	    startTimeOfVideo=newStartTimeOfVideo;	}		/**	Create a new MPEG_video object	 * 	@param	play the MPEG_Play object used to display the movie (pass instance of MPEG_Play_null)	 * 	@param	stream	the MPEG stream	 * 	@param	newMovieFile the URL of the movie	 */    	public MPEG_video (MPEG_Play play, io_tool tool,URL newMovieFile) {	    this(play,tool);	    movieFile=newMovieFile;    	}		/**	Create a new MPEG_video object	 * 	@param	play the MPEG_Play object used to display the movie (pass instance of MPEG_Play_null)	 * 	@param	stream	the MPEG stream	 */    	public MPEG_video (MPEG_Play play, io_tool tool) {	    super(play,tool);	    	    //Reassign Forward and Backward:	    Forward=new uk.ac.bham.cs.djc.MPEG_Play.motion_data();	    Backward=new uk.ac.bham.cs.djc.MPEG_Play.motion_data();	    System.gc();    	}		/**	Is the decoded set to parse frames?	 * 	@return	whether the decoded set to parse frames	 */	public synchronized boolean getPARSE_FRAMES() {	    	return(PARSE_FRAMES);	}		/**	Set whether the decoder should parse frames	 * 	@param	newValue whether the decoder should parse frames	 */	public synchronized void setPARSE_FRAMES(boolean newValue) {	    	PARSE_FRAMES=newValue;	}		/**	Has the video information been parsed?	 * 	@return	whether video information has been parsed	 */	public synchronized boolean getINFO_PARSED() {	    	return(INFO_PARSED);	}		/**	Set whether the video information been parsed	 * 	@param	newValue whether the video information been parsed	 */	public synchronized void setINFO_PARSED(boolean newValue) {	    	INFO_PARSED=newValue;	}		/**	Do parsing in a separte thread	 */	public void run() {		//Start parsing	    	    	try {			super.run();	    	}	    	finally {			setPARSE_FRAMES(false);					//Stop parsing					try {		    		(Thread.currentThread()).sleep(1000);			}			catch(InterruptedException ie) {			}	    	}	}		/**	Parse the Group of Pictures (GOP) which corespond to the times described by the cutList timeline	 */	protected void Parse_group_of_pictures() {		//Wait until frame parsing is enabled:	    	while(!getPARSE_FRAMES()){    			try{    				(Thread.currentThread()).yield();    			}    			catch(Exception e){    			}    		}				if(cutList!=null) {			int firstFrameNumberOfNewGOP=getLastFrameNumber()+1;						//If the first frame of the GOP is on the timeline - set it to be parsed parsed:			int startTime=frameToTime(firstFrameNumberOfNewGOP);			int stopTime=startTime+(int)((1.0/frameRate)*1000);			PARSE_THIS_GOP=cutList.onTimeLine(new Period(startTime,stopTime));		}		else PARSE_THIS_GOP=false;			    	super.Parse_group_of_pictures();		PARSE_THIS_GOP=false;      	}		/**	Parse an individual frame of the MPEG video	 */	protected void Parse_picture () {	    //if(this is the begining of picture data):	    if(mpeg_stream.get_bits(32) == PICTURE_START_CODE){		//Parse basic picture information:		Frame_nr = Frame_nr_offset + mpeg_stream.get_bits(10);		Pic_Type = mpeg_stream.get_bits(3);      		mpeg_stream.get_bits(3); //Ignore				//Make a new MPEG_frame object:		currentFrame=new MPEG_frame(new Period(frameToTime(Frame_nr),frameToTime(Frame_nr+1)),Frame_nr,Width,Height,Pic_Type,movieFile);				//Record last I, P and B frame:		switch(Pic_Type) {			case I_TYPE:lastIFrame=currentFrame;break;			case P_TYPE:lastPFrame=currentFrame;break;			case B_TYPE:lastBFrame=currentFrame;break;		}		System.gc();	//Want to garbage collect frames that are no longer referenced				//if this frame belongs to a GOP to be parsed:		if(PARSE_THIS_GOP) {			mpeg_stream.unget_bits(16);			mpeg_stream.unget_bits(32);						//Parse picture as normal:	    		super.Parse_picture();						//If this is an I frame:			if (Pic_Type==I_TYPE) {			    	//Extract the picture information:				    				DirectColorModel cm = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);	       			Element newFrame=new Element(new MPEG_Play_null(), cm, Width, Height, Width, Height);               							//Work out the buffer index, see super.Parse_picture() to understand why				int bufferIndex=0;				if (Pic_Type == P_TYPE || Pic_Type == I_TYPE) {					bufferIndex=back_idx;				}				else bufferIndex=ak_idx;								//Set RGB components:				newFrame.Make_Picture(Pel_buffer[bufferIndex], Frame_nr, Pic_Type);								//For each pixel in the image:				for(int index=0;index<(newFrame.Pix_Map).length;index++) {		    			int x=index%Width;		    			int y=index/Width;				    				    	int rgb=newFrame.Pix_Map[index];										int r=(rgb & 0xFF0000)>>16;					int g=(rgb & 0x00FF00)>>8;					int b=(rgb & 0x0000FF);										try {					    	//Add a pixel to the frame:						currentFrame.addPixel(new RGB_pixel(r,g,b,x,y));					}					catch(Exception e) {					    	//Couldn't make a new RGB_pixel					}				}				System.gc();			}	    	}		else{ 		    	//Skip this picture...		    	skipOverOnePicture();	    	}	    }        }		/**	Skip to the begining of the next GOP	 * 	@exception Exception if there are no more GOPs available in this sequence	 */	protected void skipToNextGOP() throws Exception{	    ((MPEG_stream)mpeg_stream).mark();	    	    do {		skipOverOnePicture();	    }	    while(!mpeg_stream.is_eof() && mpeg_stream.next_bits(PICTURE_START_CODE,32));	    	    if(!mpeg_stream.next_bits(GOP_START_CODE,32)) {		((MPEG_stream)mpeg_stream).reset();		throw new Exception("skipOneGOPForward:	No more GOPs available in this sequence");	    }	}		/**	Starting from a PICTURE_START_CODE skip to the begin of the next start code	 */	protected void skipOverOnePicture(){	    int currentBits=0;	    int numberOfBits=0;	    	    //Move forward through the stream a byte at a time and look for a start code:	    mpeg_stream.get_bits(24);	//Skip over VB delay and motion vector information + 4 bits	    	    do {		currentBits=mpeg_stream.get_bits(32);		mpeg_stream.unget_bits(24);		numberOfBits+=8;	    }while(!mpeg_stream.is_eof() && (currentBits != PICTURE_START_CODE) && (currentBits!=GOP_START_CODE) && (currentBits!=ISO_11172_END_CODE) && (currentBits!=SEQ_END_CODE));	    	    //Make it so that the next byte will be the start code:	    mpeg_stream.unget_bits(8);	}		/**	Parse a single macro-block in the frame	 * 	@param	b_nr	 */	protected void Parse_macroblock(int b_nr) {	    super.Parse_macroblock(b_nr);	    	    //Create and add a new instance of MPEG_macroblock to this frame, to represent this macroblock:	    try {    	    	if(currentFrame!=null) {	        	if(macro_block_motion_forward) {		   		currentFrame.addMacroblock(new MPEG_forwardMacroblock(b_nr,mb_row,((uk.ac.bham.cs.djc.MPEG_Play.motion_data)Forward).getMotionVector()));	        	}	        			if(macro_block_motion_backward) {		    		currentFrame.addMacroblock(new MPEG_backwardMacroblock(b_nr,mb_row,((uk.ac.bham.cs.djc.MPEG_Play.motion_data)Backward).getMotionVector()));			}	    	}	    }	    catch(Exception e) {		System.out.println(e);	    }	}		/**	Parse the sequence header which contains the video information, width, height, frame rate, etc	 */	protected void Parse_sequence_header() {	    super.Parse_sequence_header();	    	    //Work out the frame rate:	    frameRate=frameRates[Pic_rate];	    	    //The video information has now been parsed:	    setINFO_PARSED(true);	}		/** 	For a given time work out the corresponding frame	 * 	@param	time the time at which to find the corresponding frame, in milliseconds	 *	@return	the display number of the corresponding frame	 */	public int timeToFrame(int time) {	    int frame=0;	    double time_mS=(double)(time-startTimeOfVideo)*1000.0;	    	    frame=(int)(frameRate*time_mS); 	    	    return(frame);	}		/** 	For a given frame work out the corresponding time	 * 	@param	frame the display number of the frame for which to find the time	 *	@return	the time which corresponds to this frame, in milliseconds	 */	public int frameToTime(int frame) {	    int time_mS=0;	    	    time_mS=(int)((double)(frame*1000)/frameRate);	    	    return(startTimeOfVideo+time_mS);	}		/**	Get the duration of this video<br>	 * 	THE IMPLEMENTATION OF THIS IS VERY SLOW	 * 	@return	the duration of this video, in milliseconds	 * 	@exception	Exception if unable to get the duration of this video	 */	public int getDuration() throws Exception{	    int duration=0;	    	    duration=(int)((getNumberOfFrames())*(1.0/getFrameRate())*1000);	    	    return(duration);	}		/**	Get the total number of frames in this video<br>	 * 	THE IMPLEMENTATION OF THIS IS VERY SLOW	 * 	@return the total number of frames in this video	 */	public int getNumberOfFrames() {	    	//This method of frame counting does not depend on being at the start of the stream to begin with	    	int numberOfFrames=0;				currentFrame=null;		lastIFrame=null;		lastPFrame=null;		lastBFrame=null;				//Start the decoder parsing frames:		setPARSE_FRAMES(true);				//Wait until other thread has finished parsing frames:		while(getPARSE_FRAMES()){    			try{			    	(Thread.currentThread()).yield();    			}    			catch(Exception e){    			}    		}				//There are no more frames to parse, so get the last frame number:		numberOfFrames=getLastFrameNumber();				return(numberOfFrames);	}		/**	Return the number of the last parsed frame	 * 	@return the number of the last parsed frame	 */	protected int getLastFrameNumber() {	    int lastFrameNumber=0;	    	    //B-Frame is NEVER the last frame to be displayed (must follow two pre and post anchor frames) (?)	    	    //Work out the lowest frame number (as won't necessarily be last frame):	    if(lastPFrame!=null && lastIFrame!=null && lastBFrame!=null) {		lastFrameNumber=Math.max(lastIFrame.getFrameNumber(),lastPFrame.getFrameNumber());		lastFrameNumber=Math.max(lastFrameNumber,lastBFrame.getFrameNumber());	    }	    else if(lastPFrame==null && lastIFrame!=null && lastPFrame!=null) {		lastFrameNumber=Math.max(lastIFrame.getFrameNumber(),lastPFrame.getFrameNumber());	    }	    else if(lastPFrame!=null && lastIFrame!=null && lastBFrame==null) {		lastFrameNumber=Math.max(lastIFrame.getFrameNumber(),lastPFrame.getFrameNumber());	    }	    else {		//No I frame seen => not a valid MPEG stream => no frames		lastFrameNumber=0;	    }	    	    return(lastFrameNumber);	}		/**	Instruct the decoder to parse (deeply) the frames specified by this timeline	 * 	@param	sequenceToParse a timeline describing the sequences to parse	 */	public void parseSequence(TimeLine sequenceToParse) {	    //For each period in the timeline parse that time in the video	    cutList=sequenceToParse;	    	    //Now start parsing...	    setPARSE_FRAMES(true);	    	    ////Wait until other thread has finished parsing frames:	    while(getPARSE_FRAMES()){		try{ 			(Thread.currentThread()).yield();    		}    			catch(Exception e){    		}	    }	    //Now completed parsing	}		/**	Get the frame rate of this video	 * 	@return the frame rate of this video	 */	public double getFrameRate() {	    //Wait until other thread has finished parsing movie information:	    while(!getINFO_PARSED()){		try{ 			(Thread.currentThread()).yield();    		}    			catch(Exception e){    		}	    }	    	    return(frameRate);	}}