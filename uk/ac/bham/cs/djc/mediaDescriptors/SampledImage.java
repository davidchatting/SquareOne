/* Generated by Together *///20th November 1999 - DJC//16th March name changed to SampledImagepackage uk.ac.bham.cs.djc.mediaDescriptors;import java.util.Hashtable;import java.awt.Point;import java.awt.Image;import java.awt.image.PixelGrabber;import java.awt.image.ImageObserver;import uk.ac.bham.cs.djc.RGB_pixel;/**	An image sampled at a specified vertical and horizontal sample rate * 	 * 	<a href="SampledImage.java">Source code</a> * 	@author David Chatting (djc@cs.bham.ac.uk) *	@version Created 20th November 1999 */public class SampledImage extends NontemporalMediaBlock {    /**	Orignal image width in pixels */    private int width=0;        /**	Orignal image height in pixels */    private int height=0;        /**	The vertical interval in pixels between which the original image is sampled */    private int verticalSampleRate=1;        /**	The interval in pixels between which the original image is sampled */    private int horizontalSampleRate=1;        /**	Hastable containing pixels sampled from original image */    private Hashtable pixels=null;        /**	Create a new  SampledImage     *	@param	 newWidth the width of the image to sample     *	@param	 newHeight the height of the image to sample     *	@param	 newVerticalSampleRate the rate at which to sample the image - vertically     *	@param	 newHorizontalSampleRate the rate at which to sample the image - horizontally     */    public SampledImage(int newWidth,int newHeight,int newVerticalSampleRate,int newHorizontalSampleRate) {	width=newWidth;	height=newHeight;	verticalSampleRate=newVerticalSampleRate;	horizontalSampleRate=newHorizontalSampleRate;    }        /**	Create a new  SampledImage     *	@param	newWidth the width of the image to sample     *	@param	newHeight the height of the image to sample     *	@param	newVerticalSampleRate the rate at which to sample the image - vertically     *	@param	newHorizontalSampleRate the rate at which to sample the image - horizontally     *	@param	imageToSample the image to sample     *	@throws	Exception if there is a problem obtaining pixel information from the image     */    public SampledImage(int newWidth,int newHeight,int newVerticalSampleRate,int newHorizontalSampleRate, Image imageToSample) throws Exception{    	this(newWidth,newHeight,newVerticalSampleRate,newHorizontalSampleRate);		int[] pixels = new int[width * height];	PixelGrabber grabber = new PixelGrabber(imageToSample,0,0,width,height,pixels,0,width);		//Grab the pixels:	try {	    grabber.grabPixels();	} catch (InterruptedException e) {	    throw(new InterruptedException("interrupted waiting for pixels!"));	}		if ((grabber.getStatus() & ImageObserver.ABORT) != 0) {	    throw(new Exception("image fetch aborted or errored"));	}		//Add the pixels:	for (int j=0; j<height; j++) {	    for (int i=0; i<width; i++) {		int alpha = (pixels[j*width+i] >> 24) & 0xff;		int red   = (pixels[j*width+i] >> 16) & 0xff;		int green = (pixels[j*width+i] >>  8) & 0xff;		int blue  = (pixels[j*width+i]      ) & 0xff;				addPixel(new RGB_pixel(red,green,blue,i,j));	    }	}    }        /**	Add a pixel which can be sampled or rejected depending on the specified sample rates     * 	@param	newPixel the pixel to add     */    public void addPixel(RGB_pixel newPixel) {	Point newLocation=newPixel.getLocation();		//if(this pixel should be sampled)	if((newLocation.x%verticalSampleRate==0) && (newLocation.y%horizontalSampleRate==0)) {	    //Then add it...	    if(pixels==null) {		pixels= new Hashtable();	    }	    	    //The key is the location of the pixel:	    pixels.put(newPixel.getLocation(),newPixel);	}	else;	//Ignore that pixel    }        /**	Get the pixel sampled at position x,y      *	@param	x the x coordinate of the pixel to sample     *	@param	y the y coordinate of the pixel to sample     *	@return	the sampled RGB_pixel at this location     *	@throws Exception if this pixel has not been sampled     */    public RGB_pixel getPixel(int x, int y) throws Exception{	return(getPixel(new Point(x,y)));    }        /**	Get the pixel sampled at position specified by pixelLocation     * 	@param	pixelLocation the location of the pixel to sample     * 	@return	the sampled RGB_pixel at this location     * 	@throws Exception if this pixel has not been sampled     */    public RGB_pixel getPixel(Point pixelLocation) throws Exception{	RGB_pixel pixelToReturn=null;		//if(this pixel is sampled):	if((pixelLocation.x%verticalSampleRate==0) && (pixelLocation.y%horizontalSampleRate==0)) {	    //Get the pixel to return:	    pixelToReturn=(RGB_pixel)pixels.get(pixelLocation);	}	else {	    //if this pixel is not sampled:	    throw new Exception("The pixel at " + pixelLocation.x + ", " + pixelLocation.y + " is not sampled");	}		//Ensure that pixelToReturn has a value:	if(pixelToReturn==null) {	    throw new Exception("The pixel at " + pixelLocation.x + ", " + pixelLocation.y + " is not sampled");	}		return(pixelToReturn);    }        /**	Get the mean intensity of the sampled image     * 	@return the mean intensity of this image     */    public int getMeanIntensity() {	int meanIntensity=0;	int samples=0;		//For each sampled column:	for(int x=0;x<width;x+=horizontalSampleRate) {	    //For each sampled row:	    for(int y=0;y<height;y+=verticalSampleRate) {		try {		    	//Add the intensity of this pixel to the running total:			meanIntensity+=getPixel(x,y).getIntensity();			samples++;		}		catch(Exception e) {		}	    }	}		//Work out the mean:	meanIntensity/=samples;		return(meanIntensity);    }        /**	Get the width of the sampled image     * 	@return	the width of the sampled image     */    public int getWidth() {	return(width);    }        /**	Get the height of the sampled image     * 	@return	the height of the sampled image     */    public int getHeight() {	return(height);    }        /**	Get the horizontal interval in pixels, at which the sampled image     * 	@return	the horizontal interval in pixels, at which the sampled image     */    public int getHorizontalSampleRate() {	return(horizontalSampleRate);    }        /**	Get the vertical interval in pixels, at which the sampled image     * @return	the vertical interval in pixels, at which the sampled image     */    public int getVerticalSampleRate() {	return(verticalSampleRate);    }}